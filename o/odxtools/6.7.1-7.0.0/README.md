# Comparing `tmp/odxtools-6.7.1-py3-none-any.whl.zip` & `tmp/odxtools-7.0.0-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,15 +1,15 @@
-Zip file size: 233207 bytes, number of entries: 182
+Zip file size: 237285 bytes, number of entries: 182
 -rw-r--r--  2.0 unx     2357 b- defN 24-Mar-13 22:31 odxtools/__init__.py
 -rw-r--r--  2.0 unx      119 b- defN 23-Nov-02 14:58 odxtools/__main__.py
 -rw-r--r--  2.0 unx      990 b- defN 23-Nov-02 14:58 odxtools/additionalaudience.py
 -rw-r--r--  2.0 unx     1919 b- defN 23-Nov-02 14:58 odxtools/admindata.py
 -rw-r--r--  2.0 unx     3324 b- defN 23-Nov-02 14:58 odxtools/audience.py
 -rw-r--r--  2.0 unx     2418 b- defN 23-Dec-08 19:18 odxtools/basecomparam.py
--rw-r--r--  2.0 unx    13439 b- defN 24-Mar-13 22:31 odxtools/basicstructure.py
+-rw-r--r--  2.0 unx    13459 b- defN 24-Apr-29 09:43 odxtools/basicstructure.py
 -rw-r--r--  2.0 unx     2579 b- defN 23-Nov-02 14:58 odxtools/companydata.py
 -rw-r--r--  2.0 unx     2294 b- defN 23-Nov-02 14:58 odxtools/companydocinfo.py
 -rw-r--r--  2.0 unx     1390 b- defN 23-Nov-02 14:58 odxtools/companyrevisioninfo.py
 -rw-r--r--  2.0 unx     1567 b- defN 23-Nov-02 14:58 odxtools/companyspecificinfo.py
 -rw-r--r--  2.0 unx     1629 b- defN 23-Nov-02 14:58 odxtools/comparam.py
 -rw-r--r--  2.0 unx     4978 b- defN 24-Mar-13 22:31 odxtools/comparaminstance.py
 -rw-r--r--  2.0 unx     3238 b- defN 23-Nov-16 14:46 odxtools/comparamspec.py
@@ -18,93 +18,93 @@
 -rw-r--r--  2.0 unx      280 b- defN 23-Nov-06 14:13 odxtools/complexdop.py
 -rw-r--r--  2.0 unx      617 b- defN 23-Nov-02 14:58 odxtools/createanycomparam.py
 -rw-r--r--  2.0 unx     3770 b- defN 23-Nov-02 14:58 odxtools/createanydiagcodedtype.py
 -rw-r--r--  2.0 unx      582 b- defN 23-Nov-02 14:58 odxtools/createcompanydatas.py
 -rw-r--r--  2.0 unx      559 b- defN 23-Nov-02 14:58 odxtools/createecuvariantpatterns.py
 -rw-r--r--  2.0 unx      531 b- defN 23-Nov-02 14:58 odxtools/createsdgs.py
 -rw-r--r--  2.0 unx     6741 b- defN 24-Jan-19 13:46 odxtools/database.py
--rw-r--r--  2.0 unx     6324 b- defN 24-Mar-13 22:31 odxtools/dataobjectproperty.py
--rw-r--r--  2.0 unx     4883 b- defN 24-Mar-13 22:31 odxtools/decodestate.py
+-rw-r--r--  2.0 unx     6146 b- defN 24-Apr-29 09:43 odxtools/dataobjectproperty.py
+-rw-r--r--  2.0 unx     4490 b- defN 24-Apr-29 09:43 odxtools/decodestate.py
 -rw-r--r--  2.0 unx     1561 b- defN 24-Mar-13 22:31 odxtools/determinenumberofitems.py
--rw-r--r--  2.0 unx     7409 b- defN 24-Mar-13 22:31 odxtools/diagcodedtype.py
+-rw-r--r--  2.0 unx     3673 b- defN 24-Apr-29 09:43 odxtools/diagcodedtype.py
 -rw-r--r--  2.0 unx     7623 b- defN 23-Nov-21 15:07 odxtools/diagcomm.py
 -rw-r--r--  2.0 unx    10615 b- defN 24-Mar-13 22:31 odxtools/diagdatadictionaryspec.py
--rw-r--r--  2.0 unx    45120 b- defN 24-Mar-13 22:31 odxtools/diaglayer.py
+-rw-r--r--  2.0 unx    47279 b- defN 24-Apr-29 09:43 odxtools/diaglayer.py
 -rw-r--r--  2.0 unx     5877 b- defN 23-Nov-02 14:58 odxtools/diaglayercontainer.py
 -rw-r--r--  2.0 unx    13945 b- defN 23-Nov-21 15:07 odxtools/diaglayerraw.py
 -rw-r--r--  2.0 unx     1340 b- defN 24-Mar-13 22:31 odxtools/diaglayertype.py
 -rw-r--r--  2.0 unx     2496 b- defN 23-Nov-02 14:58 odxtools/diagnostictroublecode.py
--rw-r--r--  2.0 unx     9788 b- defN 24-Mar-13 22:31 odxtools/diagservice.py
+-rw-r--r--  2.0 unx     9609 b- defN 24-Apr-29 09:43 odxtools/diagservice.py
 -rw-r--r--  2.0 unx     2738 b- defN 23-Nov-02 14:58 odxtools/docrevision.py
--rw-r--r--  2.0 unx     2635 b- defN 24-Mar-13 22:31 odxtools/dopbase.py
--rw-r--r--  2.0 unx     7504 b- defN 24-Mar-13 22:31 odxtools/dtcdop.py
--rw-r--r--  2.0 unx     5020 b- defN 24-Mar-13 22:31 odxtools/dynamiclengthfield.py
+-rw-r--r--  2.0 unx     2520 b- defN 24-Apr-29 09:43 odxtools/dopbase.py
+-rw-r--r--  2.0 unx     7456 b- defN 24-Apr-29 09:43 odxtools/dtcdop.py
+-rw-r--r--  2.0 unx     5324 b- defN 24-Apr-29 09:43 odxtools/dynamiclengthfield.py
 -rw-r--r--  2.0 unx     6882 b- defN 23-Nov-02 14:58 odxtools/ecuvariantmatcher.py
 -rw-r--r--  2.0 unx      863 b- defN 23-Nov-02 14:58 odxtools/ecuvariantpattern.py
 -rw-r--r--  2.0 unx     1209 b- defN 23-Nov-02 14:58 odxtools/element.py
--rw-r--r--  2.0 unx     2131 b- defN 24-Feb-20 08:59 odxtools/encodestate.py
--rw-r--r--  2.0 unx     2801 b- defN 24-Mar-13 22:31 odxtools/endofpdufield.py
+-rw-r--r--  2.0 unx     9378 b- defN 24-Apr-29 09:43 odxtools/encodestate.py
+-rw-r--r--  2.0 unx     2747 b- defN 24-Apr-29 09:43 odxtools/endofpdufield.py
 -rw-r--r--  2.0 unx     1144 b- defN 23-Nov-21 15:07 odxtools/environmentdata.py
--rw-r--r--  2.0 unx     4347 b- defN 24-Mar-13 22:31 odxtools/environmentdatadescription.py
+-rw-r--r--  2.0 unx     4181 b- defN 24-Apr-29 09:43 odxtools/environmentdatadescription.py
 -rw-r--r--  2.0 unx     2505 b- defN 23-Nov-02 14:58 odxtools/exceptions.py
 -rw-r--r--  2.0 unx     3829 b- defN 23-Nov-21 15:07 odxtools/field.py
 -rw-r--r--  2.0 unx      985 b- defN 23-Nov-02 14:58 odxtools/functionalclass.py
 -rw-r--r--  2.0 unx      139 b- defN 23-Nov-02 14:58 odxtools/globals.py
 -rw-r--r--  2.0 unx     1875 b- defN 24-Mar-13 22:31 odxtools/inputparam.py
 -rw-r--r--  2.0 unx     1363 b- defN 24-Mar-13 22:31 odxtools/internalconstr.py
 -rw-r--r--  2.0 unx    13339 b- defN 24-Mar-13 22:31 odxtools/isotp_state_machine.py
--rw-r--r--  2.0 unx     3171 b- defN 24-Feb-20 08:59 odxtools/leadinglengthinfotype.py
+-rw-r--r--  2.0 unx     3664 b- defN 24-Apr-29 09:43 odxtools/leadinglengthinfotype.py
 -rw-r--r--  2.0 unx      461 b- defN 23-Nov-02 14:58 odxtools/load_file.py
 -rw-r--r--  2.0 unx      172 b- defN 23-Nov-02 14:58 odxtools/load_odx_d_file.py
 -rw-r--r--  2.0 unx      186 b- defN 23-Nov-02 14:58 odxtools/load_pdx_file.py
 -rw-r--r--  2.0 unx     2229 b- defN 23-Nov-02 14:58 odxtools/matchingparameter.py
 -rw-r--r--  2.0 unx     1057 b- defN 24-Mar-13 22:31 odxtools/message.py
--rw-r--r--  2.0 unx     7879 b- defN 24-Feb-20 08:59 odxtools/minmaxlengthtype.py
+-rw-r--r--  2.0 unx     8114 b- defN 24-Apr-29 09:43 odxtools/minmaxlengthtype.py
 -rw-r--r--  2.0 unx      872 b- defN 23-Nov-02 14:58 odxtools/modification.py
--rw-r--r--  2.0 unx     7618 b- defN 24-Mar-13 22:31 odxtools/multiplexer.py
--rw-r--r--  2.0 unx     3126 b- defN 24-Mar-13 22:31 odxtools/multiplexercase.py
+-rw-r--r--  2.0 unx     8354 b- defN 24-Apr-29 09:43 odxtools/multiplexer.py
+-rw-r--r--  2.0 unx     3124 b- defN 24-Apr-29 09:43 odxtools/multiplexercase.py
 -rw-r--r--  2.0 unx     1979 b- defN 23-Nov-02 14:58 odxtools/multiplexerdefaultcase.py
 -rw-r--r--  2.0 unx     1554 b- defN 24-Mar-13 22:31 odxtools/multiplexerswitchkey.py
--rw-r--r--  2.0 unx     6164 b- defN 24-Mar-13 22:31 odxtools/nameditemlist.py
+-rw-r--r--  2.0 unx     6539 b- defN 24-Apr-29 09:43 odxtools/nameditemlist.py
 -rw-r--r--  2.0 unx     1407 b- defN 23-Nov-02 14:58 odxtools/negoutputparam.py
 -rw-r--r--  2.0 unx     1860 b- defN 23-Nov-02 14:58 odxtools/obd.py
 -rw-r--r--  2.0 unx     8932 b- defN 24-Mar-13 22:31 odxtools/odxlink.py
--rw-r--r--  2.0 unx     7036 b- defN 24-Mar-13 22:31 odxtools/odxtypes.py
+-rw-r--r--  2.0 unx     7495 b- defN 24-Apr-29 09:43 odxtools/odxtypes.py
 -rw-r--r--  2.0 unx     1670 b- defN 24-Mar-13 22:31 odxtools/outputparam.py
--rw-r--r--  2.0 unx     3951 b- defN 24-Mar-13 22:31 odxtools/parameterinfo.py
--rw-r--r--  2.0 unx     3718 b- defN 24-Mar-13 22:31 odxtools/paramlengthinfotype.py
+-rw-r--r--  2.0 unx     8147 b- defN 24-Apr-29 09:43 odxtools/parameterinfo.py
+-rw-r--r--  2.0 unx     4155 b- defN 24-Apr-29 09:43 odxtools/paramlengthinfotype.py
 -rw-r--r--  2.0 unx     3316 b- defN 24-Mar-13 22:31 odxtools/parentref.py
 -rw-r--r--  2.0 unx     3393 b- defN 23-Nov-02 14:58 odxtools/physicaldimension.py
 -rw-r--r--  2.0 unx     2699 b- defN 23-Nov-02 14:58 odxtools/physicaltype.py
 -rw-r--r--  2.0 unx     1765 b- defN 23-Nov-02 14:58 odxtools/progcode.py
 -rw-r--r--  2.0 unx     2046 b- defN 23-Nov-21 15:07 odxtools/protstack.py
 -rw-r--r--  2.0 unx     1335 b- defN 23-Nov-02 14:58 odxtools/relateddoc.py
--rw-r--r--  2.0 unx      719 b- defN 23-Nov-21 15:07 odxtools/request.py
--rw-r--r--  2.0 unx     2030 b- defN 23-Nov-21 15:07 odxtools/response.py
+-rw-r--r--  2.0 unx     1029 b- defN 24-Apr-29 09:43 odxtools/request.py
+-rw-r--r--  2.0 unx     1599 b- defN 24-Apr-29 09:43 odxtools/response.py
 -rw-r--r--  2.0 unx     1780 b- defN 24-Mar-13 22:31 odxtools/scaleconstr.py
 -rw-r--r--  2.0 unx     3859 b- defN 23-Nov-02 14:58 odxtools/servicebinner.py
 -rw-r--r--  2.0 unx     3891 b- defN 23-Nov-02 14:58 odxtools/singleecujob.py
 -rw-r--r--  2.0 unx     1067 b- defN 23-Nov-02 14:58 odxtools/specialdata.py
 -rw-r--r--  2.0 unx     3077 b- defN 23-Nov-02 14:58 odxtools/specialdatagroup.py
 -rw-r--r--  2.0 unx     1039 b- defN 23-Nov-02 14:58 odxtools/specialdatagroupcaption.py
--rw-r--r--  2.0 unx     2433 b- defN 24-Feb-20 08:59 odxtools/standardlengthtype.py
+-rw-r--r--  2.0 unx     3876 b- defN 24-Apr-29 09:43 odxtools/standardlengthtype.py
 -rw-r--r--  2.0 unx      932 b- defN 23-Nov-02 14:58 odxtools/state.py
 -rw-r--r--  2.0 unx     3246 b- defN 23-Nov-02 14:58 odxtools/statechart.py
 -rw-r--r--  2.0 unx     2206 b- defN 24-Mar-13 22:31 odxtools/statetransition.py
--rw-r--r--  2.0 unx     3846 b- defN 24-Mar-13 22:31 odxtools/staticfield.py
+-rw-r--r--  2.0 unx     3994 b- defN 24-Apr-29 09:43 odxtools/staticfield.py
 -rw-r--r--  2.0 unx      582 b- defN 23-Nov-21 15:07 odxtools/structure.py
 -rw-r--r--  2.0 unx     4051 b- defN 24-Mar-13 22:31 odxtools/table.py
 -rw-r--r--  2.0 unx     6149 b- defN 24-Mar-13 22:31 odxtools/tablerow.py
 -rw-r--r--  2.0 unx     1806 b- defN 23-Nov-02 14:58 odxtools/teammember.py
 -rw-r--r--  2.0 unx     5894 b- defN 24-Mar-13 22:31 odxtools/uds.py
 -rw-r--r--  2.0 unx     3701 b- defN 23-Nov-02 14:58 odxtools/unit.py
 -rw-r--r--  2.0 unx     2101 b- defN 23-Nov-02 14:58 odxtools/unitgroup.py
 -rw-r--r--  2.0 unx     2981 b- defN 23-Nov-02 14:58 odxtools/unitspec.py
 -rw-r--r--  2.0 unx     1983 b- defN 23-Nov-02 14:58 odxtools/utils.py
--rw-r--r--  2.0 unx      411 b- defN 24-Mar-27 10:30 odxtools/version.py
+-rw-r--r--  2.0 unx      411 b- defN 24-Apr-29 09:43 odxtools/version.py
 -rw-r--r--  2.0 unx     7307 b- defN 24-Mar-13 22:31 odxtools/write_pdx_file.py
 -rw-r--r--  2.0 unx     1467 b- defN 23-Nov-02 14:58 odxtools/xdoc.py
 -rw-r--r--  2.0 unx      106 b- defN 23-Nov-02 14:58 odxtools/cli/__init__.py
 -rw-r--r--  2.0 unx     1117 b- defN 24-Mar-13 22:31 odxtools/cli/_parser_utils.py
 -rw-r--r--  2.0 unx    10284 b- defN 24-Mar-13 22:31 odxtools/cli/_print_utils.py
 -rw-r--r--  2.0 unx    15797 b- defN 24-Mar-13 22:31 odxtools/cli/browse.py
 -rw-r--r--  2.0 unx    36768 b- defN 24-Mar-13 22:31 odxtools/cli/compare.py
@@ -120,29 +120,29 @@
 -rw-r--r--  2.0 unx     7154 b- defN 24-Mar-27 10:30 odxtools/compumethods/createanycompumethod.py
 -rw-r--r--  2.0 unx      830 b- defN 23-Nov-02 14:58 odxtools/compumethods/identicalcompumethod.py
 -rw-r--r--  2.0 unx     4164 b- defN 24-Mar-13 22:31 odxtools/compumethods/limit.py
 -rw-r--r--  2.0 unx     7690 b- defN 24-Mar-13 22:31 odxtools/compumethods/linearcompumethod.py
 -rw-r--r--  2.0 unx     1644 b- defN 23-Nov-02 14:58 odxtools/compumethods/scalelinearcompumethod.py
 -rw-r--r--  2.0 unx     7302 b- defN 24-Mar-13 22:31 odxtools/compumethods/tabintpcompumethod.py
 -rw-r--r--  2.0 unx     3347 b- defN 24-Mar-13 22:31 odxtools/compumethods/texttablecompumethod.py
--rw-r--r--  2.0 unx     4213 b- defN 24-Mar-13 22:31 odxtools/parameters/codedconstparameter.py
+-rw-r--r--  2.0 unx     4232 b- defN 24-Apr-29 09:43 odxtools/parameters/codedconstparameter.py
 -rw-r--r--  2.0 unx     2566 b- defN 24-Mar-13 22:31 odxtools/parameters/createanyparameter.py
--rw-r--r--  2.0 unx     1483 b- defN 24-Mar-13 22:31 odxtools/parameters/dynamicparameter.py
--rw-r--r--  2.0 unx     3375 b- defN 24-Mar-13 22:31 odxtools/parameters/lengthkeyparameter.py
--rw-r--r--  2.0 unx     2354 b- defN 24-Mar-13 22:31 odxtools/parameters/matchingrequestparameter.py
--rw-r--r--  2.0 unx     4749 b- defN 24-Mar-13 22:31 odxtools/parameters/nrcconstparameter.py
--rw-r--r--  2.0 unx     6306 b- defN 24-Mar-13 22:31 odxtools/parameters/parameter.py
--rw-r--r--  2.0 unx     3757 b- defN 24-Mar-13 22:31 odxtools/parameters/parameterwithdop.py
--rw-r--r--  2.0 unx     3759 b- defN 24-Mar-13 22:31 odxtools/parameters/physicalconstantparameter.py
--rw-r--r--  2.0 unx     1744 b- defN 24-Mar-13 22:31 odxtools/parameters/reservedparameter.py
--rw-r--r--  2.0 unx     1694 b- defN 24-Mar-13 22:31 odxtools/parameters/systemparameter.py
--rw-r--r--  2.0 unx     2324 b- defN 24-Mar-13 22:31 odxtools/parameters/tableentryparameter.py
--rw-r--r--  2.0 unx     7700 b- defN 24-Mar-13 22:31 odxtools/parameters/tablekeyparameter.py
--rw-r--r--  2.0 unx     7148 b- defN 24-Mar-13 22:31 odxtools/parameters/tablestructparameter.py
--rw-r--r--  2.0 unx     3330 b- defN 24-Mar-13 22:31 odxtools/parameters/valueparameter.py
+-rw-r--r--  2.0 unx     1569 b- defN 24-Apr-29 09:43 odxtools/parameters/dynamicparameter.py
+-rw-r--r--  2.0 unx     5761 b- defN 24-Apr-29 09:43 odxtools/parameters/lengthkeyparameter.py
+-rw-r--r--  2.0 unx     2897 b- defN 24-Apr-29 09:43 odxtools/parameters/matchingrequestparameter.py
+-rw-r--r--  2.0 unx     5589 b- defN 24-Apr-29 09:43 odxtools/parameters/nrcconstparameter.py
+-rw-r--r--  2.0 unx     5955 b- defN 24-Apr-29 09:43 odxtools/parameters/parameter.py
+-rw-r--r--  2.0 unx     3595 b- defN 24-Apr-29 09:43 odxtools/parameters/parameterwithdop.py
+-rw-r--r--  2.0 unx     3630 b- defN 24-Apr-29 09:43 odxtools/parameters/physicalconstantparameter.py
+-rw-r--r--  2.0 unx     1930 b- defN 24-Apr-29 09:43 odxtools/parameters/reservedparameter.py
+-rw-r--r--  2.0 unx     1784 b- defN 24-Apr-29 09:43 odxtools/parameters/systemparameter.py
+-rw-r--r--  2.0 unx     2414 b- defN 24-Apr-29 09:43 odxtools/parameters/tableentryparameter.py
+-rw-r--r--  2.0 unx     9768 b- defN 24-Apr-29 09:43 odxtools/parameters/tablekeyparameter.py
+-rw-r--r--  2.0 unx     7977 b- defN 24-Apr-29 09:43 odxtools/parameters/tablestructparameter.py
+-rw-r--r--  2.0 unx     3100 b- defN 24-Apr-29 09:43 odxtools/parameters/valueparameter.py
 -rw-r--r--  2.0 unx     1562 b- defN 23-Nov-21 15:07 odxtools/templates/comparam-spec.odx-c.xml.jinja2
 -rw-r--r--  2.0 unx     2522 b- defN 23-Nov-21 15:07 odxtools/templates/comparam-subset.odx-cs.xml.jinja2
 -rw-r--r--  2.0 unx     2026 b- defN 23-Nov-02 14:58 odxtools/templates/diag_layer_container.odx-d.xml.jinja2
 -rw-r--r--  2.0 unx      636 b- defN 23-Nov-02 14:58 odxtools/templates/index.xml.xml.jinja2
 -rw-r--r--  2.0 unx     2590 b- defN 23-Nov-02 14:58 odxtools/templates/macros/printAdminData.xml.jinja2
 -rw-r--r--  2.0 unx     1278 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printAudience.xml.jinja2
 -rw-r--r--  2.0 unx      614 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printBasicStructure.xml.jinja2
@@ -171,14 +171,14 @@
 -rw-r--r--  2.0 unx      943 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printStateChart.xml.jinja2
 -rw-r--r--  2.0 unx      502 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printStateTransition.xml.jinja2
 -rw-r--r--  2.0 unx      513 b- defN 24-Mar-13 22:31 odxtools/templates/macros/printStaticField.xml.jinja2
 -rw-r--r--  2.0 unx      559 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printStructure.xml.jinja2
 -rw-r--r--  2.0 unx     1466 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printTable.xml.jinja2
 -rw-r--r--  2.0 unx     2813 b- defN 23-Nov-21 15:07 odxtools/templates/macros/printUnitSpec.xml.jinja2
 -rw-r--r--  2.0 unx     6934 b- defN 24-Mar-13 22:31 odxtools/templates/macros/printVariant.xml.jinja2
--rw-r--r--  2.0 unx     1074 b- defN 24-Mar-27 10:30 odxtools-6.7.1.dist-info/LICENSE
--rw-r--r--  2.0 unx    44108 b- defN 24-Mar-27 10:30 odxtools-6.7.1.dist-info/METADATA
--rw-r--r--  2.0 unx       92 b- defN 24-Mar-27 10:30 odxtools-6.7.1.dist-info/WHEEL
--rw-r--r--  2.0 unx       53 b- defN 24-Mar-27 10:30 odxtools-6.7.1.dist-info/entry_points.txt
--rw-r--r--  2.0 unx        9 b- defN 24-Mar-27 10:30 odxtools-6.7.1.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    16152 b- defN 24-Mar-27 10:30 odxtools-6.7.1.dist-info/RECORD
-182 files, 702226 bytes uncompressed, 207613 bytes compressed:  70.4%
+-rw-r--r--  2.0 unx     1074 b- defN 24-Apr-29 09:43 odxtools-7.0.0.dist-info/LICENSE
+-rw-r--r--  2.0 unx    44108 b- defN 24-Apr-29 09:43 odxtools-7.0.0.dist-info/METADATA
+-rw-r--r--  2.0 unx       92 b- defN 24-Apr-29 09:43 odxtools-7.0.0.dist-info/WHEEL
+-rw-r--r--  2.0 unx       53 b- defN 24-Apr-29 09:43 odxtools-7.0.0.dist-info/entry_points.txt
+-rw-r--r--  2.0 unx        9 b- defN 24-Apr-29 09:43 odxtools-7.0.0.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    16153 b- defN 24-Apr-29 09:43 odxtools-7.0.0.dist-info/RECORD
+182 files, 721752 bytes uncompressed, 211691 bytes compressed:  70.7%
```

## zipnote {}

```diff
@@ -522,26 +522,26 @@
 
 Filename: odxtools/templates/macros/printUnitSpec.xml.jinja2
 Comment: 
 
 Filename: odxtools/templates/macros/printVariant.xml.jinja2
 Comment: 
 
-Filename: odxtools-6.7.1.dist-info/LICENSE
+Filename: odxtools-7.0.0.dist-info/LICENSE
 Comment: 
 
-Filename: odxtools-6.7.1.dist-info/METADATA
+Filename: odxtools-7.0.0.dist-info/METADATA
 Comment: 
 
-Filename: odxtools-6.7.1.dist-info/WHEEL
+Filename: odxtools-7.0.0.dist-info/WHEEL
 Comment: 
 
-Filename: odxtools-6.7.1.dist-info/entry_points.txt
+Filename: odxtools-7.0.0.dist-info/entry_points.txt
 Comment: 
 
-Filename: odxtools-6.7.1.dist-info/top_level.txt
+Filename: odxtools-7.0.0.dist-info/top_level.txt
 Comment: 
 
-Filename: odxtools-6.7.1.dist-info/RECORD
+Filename: odxtools-7.0.0.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## odxtools/basicstructure.py

```diff
@@ -1,13 +1,15 @@
 # SPDX-License-Identifier: MIT
 import warnings
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, List, Optional, cast
 from xml.etree import ElementTree
 
+from typing_extensions import override
+
 from .complexdop import ComplexDop
 from .dataobjectproperty import DataObjectProperty
 from .decodestate import DecodeState
 from .encodestate import EncodeState
 from .exceptions import DecodeError, EncodeError, OdxWarning, odxassert, odxraise, strict_mode
 from .nameditemlist import NamedItemList
 from .odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
@@ -17,14 +19,15 @@
 from .parameters.lengthkeyparameter import LengthKeyParameter
 from .parameters.matchingrequestparameter import MatchingRequestParameter
 from .parameters.nrcconstparameter import NrcConstParameter
 from .parameters.parameter import Parameter
 from .parameters.parameterwithdop import ParameterWithDOP
 from .parameters.physicalconstantparameter import PhysicalConstantParameter
 from .parameters.tablekeyparameter import TableKeyParameter
+from .parameters.tablestructparameter import TableStructParameter
 from .utils import dataclass_fields_asdict
 
 if TYPE_CHECKING:
     from .diaglayer import DiagLayer
 
 
 @dataclass
@@ -50,40 +53,37 @@
 
     def get_static_bit_length(self) -> Optional[int]:
         # Explicit size was specified
         if self.byte_size:
             return 8 * self.byte_size
 
         cursor = 0
-        length = 0
+        byte_length = 0
         for param in self.parameters:
             param_bit_length = param.get_static_bit_length()
             if param_bit_length is None:
                 # We were not able to calculate a static bit length
                 return None
             elif param.byte_position is not None:
-                bit_pos = param.bit_position or 0
-                byte_pos = param.byte_position or 0
-                cursor = byte_pos * 8 + bit_pos
+                cursor = param.byte_position
 
-            cursor += param_bit_length
-            length = max(length, cursor)
+            cursor += ((param.bit_position or 0) + param_bit_length + 7) // 8
+            byte_length = max(byte_length, cursor)
 
         # Round up to account for padding bits (all structures are
         # byte aligned)
-        return ((length + 7) // 8) * 8
+        return byte_length * 8
 
     def coded_const_prefix(self, request_prefix: bytes = b'') -> bytes:
-        prefix = b''
-        encode_state = EncodeState(
-            bytearray(prefix), parameter_values={}, triggering_request=request_prefix)
+        encode_state = EncodeState(coded_message=bytearray(), triggering_request=request_prefix)
+
         for param in self.parameters:
-            if isinstance(param, (CodedConstParameter, NrcConstParameter, MatchingRequestParameter,
-                                  PhysicalConstantParameter)):
-                encode_state.coded_message = bytearray(param.encode_into_pdu(encode_state))
+            if (isinstance(param, MatchingRequestParameter) and param.request_byte_position < len(request_prefix)) or \
+                isinstance(param, (CodedConstParameter, NrcConstParameter, PhysicalConstantParameter)):
+                param.encode_into_pdu(physical_value=None, encode_state=encode_state)
             else:
                 break
         return encode_state.coded_message
 
     @property
     def required_parameters(self) -> List[Parameter]:
         """Return the list of parameters which are required for
@@ -112,125 +112,129 @@
         """Return a human readable description of the structure's
         free parameters.
         """
         from .parameterinfo import parameter_info
 
         print(parameter_info(self.free_parameters), end="")
 
-    def convert_physical_to_internal(self,
-                                     param_value: ParameterValue,
-                                     triggering_coded_request: Optional[bytes],
-                                     is_end_of_pdu: bool = True) -> bytes:
+    def _validate_coded_message_size(self, coded_byte_len: int) -> None:
+
+        if self.byte_size is not None:
+            # We definitely broke something if we didn't respect the explicit byte_size
+            if self.byte_size != coded_byte_len:
+                warnings.warn(
+                    "Verification of coded message failed: Incorrect size.",
+                    OdxWarning,
+                    stacklevel=1)
+
+            return
+
+        bit_length = self.get_static_bit_length()
+
+        if bit_length is None:
+            # Nothing to check
+            return
+
+        if coded_byte_len * 8 != bit_length:
+            # We may have broke something
+            # but it could be that bit_length was mis calculated and not the actual bytes are wrong
+            # Could happen with overlapping parameters and parameters with gaps
+            warnings.warn(
+                "Verification of coded message possibly failed: Size may be incorrect.",
+                OdxWarning,
+                stacklevel=1)
 
-        if not isinstance(param_value, dict):
-            raise EncodeError(
+    @override
+    def encode_into_pdu(self, physical_value: Optional[ParameterValue],
+                        encode_state: EncodeState) -> None:
+        if not isinstance(physical_value, dict):
+            odxraise(
                 f"Expected a dictionary for the values of structure {self.short_name}, "
-                f"got {type(param_value)}")
+                f"got {type(physical_value).__name__}", EncodeError)
+        elif encode_state.cursor_bit_position != 0:
+            odxraise(
+                f"Structures must be byte aligned, but "
+                f"{self.short_name} requested to be at bit position "
+                f"{encode_state.cursor_bit_position}", EncodeError)
+            encode_state.bit_position = 0
+
+        orig_cursor = encode_state.cursor_byte_position
+        orig_origin = encode_state.origin_byte_position
+        encode_state.origin_byte_position = encode_state.cursor_byte_position
+
+        orig_is_end_of_pdu = encode_state.is_end_of_pdu
+        encode_state.is_end_of_pdu = False
 
         # in strict mode, ensure that no values for unknown parameters are specified.
         if strict_mode:
-            param_names = [param.short_name for param in self.parameters]
-            for param_key in param_value:
-                if param_key not in param_names:
-                    odxraise(f"Value for unknown parameter '{param_key}' specified")
-
-        encode_state = EncodeState(
-            bytearray(),
-            dict(param_value),
-            triggering_request=triggering_coded_request,
-            is_end_of_pdu=False,
-        )
+            param_names = {param.short_name for param in self.parameters}
+            for param_value_name in physical_value:
+                if param_value_name not in param_names:
+                    odxraise(f"Value for unknown parameter '{param_value_name}' specified "
+                             f"for structure {self.short_name}")
 
         for param in self.parameters:
-            if param == self.parameters[-1]:
-                # The last parameter is at the end of the PDU if the
-                # structure itself is at the end of the PDU. TODO:
-                # This assumes that the last parameter specified in
-                # the ODX is located last in the PDU...
-                encode_state.is_end_of_pdu = is_end_of_pdu
-
-            if isinstance(
-                    param,
-                (LengthKeyParameter, TableKeyParameter)) and param.short_name in param_value:
-                # This is a hack to always encode a dummy value for
-                # length- and table keys. since these can be specified
+            if id(param) == id(self.parameters[-1]):
+                # The last parameter of the structure is at the end of
+                # the PDU if the structure itself is at the end of the
+                # PDU. TODO: This assumes that the last parameter
+                # specified in the ODX is located last in the PDU...
+                encode_state.is_end_of_pdu = orig_is_end_of_pdu
+
+            if isinstance(param, (LengthKeyParameter, TableKeyParameter)):
+                # At this point, we encode a placeholder value for length-
+                # and table keys, since these can be specified
                 # implicitly (i.e., by means of parameters that use
-                # these keys), to avoid getting an "overlapping
+                # these keys). To avoid getting an "overlapping
                 # parameter" warning, we must encode a value of zero
                 # into the PDU here and add the real value of the
-                # parameter in a post processing step.
-                tmp = encode_state.parameter_values.pop(param.short_name)
-                encode_state.coded_message = bytearray(param.encode_into_pdu(encode_state))
-                encode_state.parameter_values[param.short_name] = tmp
+                # parameter in a post-processing step.
+                param.encode_placeholder_into_pdu(
+                    physical_value=physical_value.get(param.short_name), encode_state=encode_state)
+
                 continue
 
-            encode_state.coded_message = bytearray(param.encode_into_pdu(encode_state))
+            if param.is_required and param.short_name not in physical_value:
+                odxraise(f"No value for required parameter {param.short_name} specified",
+                         EncodeError)
+
+            param.encode_into_pdu(
+                physical_value=physical_value.get(param.short_name), encode_state=encode_state)
 
-        if self.byte_size is not None and len(encode_state.coded_message) < self.byte_size:
-            # Padding bytes needed
-            encode_state.coded_message = encode_state.coded_message.ljust(self.byte_size, b"\0")
+        encode_state.is_end_of_pdu = False
+        if self.byte_size is not None:
+            actual_len = encode_state.cursor_byte_position - encode_state.origin_byte_position
+            if actual_len < self.byte_size:
+                # Padding bytes needed. We add an empty object at the
+                # position directly after the structure and let
+                # EncodeState add the padding as needed.
+                encode_state.cursor_byte_position = encode_state.origin_byte_position + self.byte_size
+                # Padding bytes needed. these count as "used".
+                encode_state.coded_message += b"\x00" * (self.byte_size - actual_len)
+                encode_state.used_mask += b"\xff" * (self.byte_size - actual_len)
 
         # encode the length- and table keys. This cannot be done above
         # because we allow these to be defined implicitly (i.e. they
         # are defined by their respective users)
         for param in self.parameters:
             if not isinstance(param, (LengthKeyParameter, TableKeyParameter)):
                 # the current parameter is neither a length- nor a table key
                 continue
 
-            # Encode the key parameter into the message
-            encode_state.coded_message = bytearray(param.encode_into_pdu(encode_state))
+            # Encode the value of the key parameter into the message
+            param.encode_value_into_pdu(encode_state=encode_state)
 
         # Assert that length is as expected
-        self._validate_coded_message(encode_state.coded_message)
-
-        return bytearray(encode_state.coded_message)
-
-    def _validate_coded_message(self, coded_message: bytes) -> None:
-
-        if self.byte_size is not None:
-            # We definitely broke something if we didn't respect the explicit byte_size
-            odxassert(
-                len(coded_message) == self.byte_size,
-                "Verification of coded message {coded_message.hex()} failed: Incorrect size.")
-            # No need to check further
-            return
-
-        bit_length = self.get_static_bit_length()
-
-        if bit_length is None:
-            # Nothing to check
-            return
+        self._validate_coded_message_size(encode_state.cursor_byte_position -
+                                          encode_state.origin_byte_position)
 
-        if len(coded_message) * 8 != bit_length:
-            # We may have broke something
-            # but it could be that bit_length was mis calculated and not the actual bytes are wrong
-            # Could happen with overlapping parameters and parameters with gaps
-            warnings.warn(
-                f"Verification of coded message '{coded_message.hex()}' possibly failed: Size may be incorrect.",
-                OdxWarning,
-                stacklevel=1)
-
-    def convert_physical_to_bytes(self,
-                                  physical_value: ParameterValue,
-                                  encode_state: EncodeState,
-                                  bit_position: int = 0) -> bytes:
-        if not isinstance(physical_value, dict):
-            raise EncodeError(
-                f"Expected a dictionary for the values of structure {self.short_name}, "
-                f"got {type(physical_value)}")
-        if bit_position != 0:
-            raise EncodeError("Structures must be aligned, i.e. bit_position=0, but "
-                              f"{self.short_name} was passed the bit position {bit_position}")
-        return self.convert_physical_to_internal(
-            physical_value,
-            triggering_coded_request=encode_state.triggering_request,
-            is_end_of_pdu=encode_state.is_end_of_pdu,
-        )
+        encode_state.origin_byte_position = orig_origin
+        encode_state.cursor_byte_position = max(orig_cursor, encode_state.cursor_byte_position)
 
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         # move the origin since positions specified by sub-parameters of
         # structures are relative to the beginning of the structure object.
         orig_origin = decode_state.origin_byte_position
         decode_state.origin_byte_position = decode_state.cursor_byte_position
 
         result = {}
@@ -240,27 +244,14 @@
             result[param.short_name] = value
 
         # decoding of the structure finished. go back the original origin.
         decode_state.origin_byte_position = orig_origin
 
         return result
 
-    def encode(self, coded_request: Optional[bytes] = None, **params: ParameterValue) -> bytes:
-        """
-        Composes an UDS message as bytes for this service.
-        Parameters:
-        ----------
-        coded_request: bytes
-            coded request (only needed when encoding a response)
-        params: dict
-            Parameters of the RPC as mapping from SHORT-NAME of the parameter to the value
-        """
-        return self.convert_physical_to_internal(
-            params, triggering_coded_request=coded_request, is_end_of_pdu=True)
-
     def decode(self, message: bytes) -> ParameterValueDict:
         decode_state = DecodeState(coded_message=message)
         param_values = self.decode_from_pdu(decode_state)
 
         if len(message) != decode_state.cursor_byte_position:
             odxraise(
                 f"The message {message.hex()} probably could not be completely parsed:"
@@ -312,8 +303,11 @@
             param._resolve_odxlinks(odxlinks)
 
     def _resolve_snrefs(self, diag_layer: "DiagLayer") -> None:
         """Recursively resolve any references (odxlinks or sn-refs)"""
         super()._resolve_snrefs(diag_layer)
 
         for param in self.parameters:
-            param._resolve_snrefs(diag_layer)
+            if isinstance(param, TableStructParameter):
+                param._table_struct_resolve_snrefs(diag_layer, param_list=self.parameters)
+            else:
+                param._resolve_snrefs(diag_layer)
```

## odxtools/dataobjectproperty.py

```diff
@@ -116,29 +116,25 @@
         """
         odxassert(
             self.physical_type.base_data_type.isinstance(physical_value),
             f"Expected {self.physical_type.base_data_type.value}, got {type(physical_value)}")
 
         return self.compu_method.convert_physical_to_internal(physical_value)
 
-    def convert_physical_to_bytes(self,
-                                  physical_value: Any,
-                                  encode_state: EncodeState,
-                                  bit_position: int = 0) -> bytes:
+    def encode_into_pdu(self, physical_value: ParameterValue, encode_state: EncodeState) -> None:
         """
         Convert a physical representation of a parameter to a string bytes that can be send over the wire
         """
         if not self.is_valid_physical_value(physical_value):
             raise EncodeError(
                 f"The value {repr(physical_value)} of type {type(physical_value).__name__}"
                 f" is not a valid.")
 
-        internal_val = self.convert_physical_to_internal(physical_value)
-        return self.diag_coded_type.convert_internal_to_bytes(
-            internal_val, encode_state, bit_position=bit_position)
+        internal_value = self.convert_physical_to_internal(physical_value)
+        self.diag_coded_type.encode_into_pdu(internal_value, encode_state)
 
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         """
         Convert the internal representation of a value into its physical value.
 
         Returns a (physical_value, start_position_of_next_parameter) tuple.
         """
```

## odxtools/decodestate.py

```diff
@@ -11,26 +11,14 @@
     import bitstruct.c as bitstruct
 except ImportError:
     import bitstruct
 
 if TYPE_CHECKING:
     from .tablerow import TableRow
 
-# format specifiers for the data type using the bitstruct module
-ODX_TYPE_TO_FORMAT_LETTER = {
-    DataType.A_INT32: "s",
-    DataType.A_UINT32: "u",
-    DataType.A_FLOAT32: "f",
-    DataType.A_FLOAT64: "f",
-    DataType.A_BYTEFIELD: "r",
-    DataType.A_UNICODE2STRING: "r",  # UTF-16 strings must be converted explicitly
-    DataType.A_ASCIISTRING: "r",
-    DataType.A_UTF8STRING: "r",
-}
-
 
 @dataclass
 class DecodeState:
     """Utility class to be used while decoding a message."""
 
     #: bytes to be decoded
     coded_message: bytes
@@ -90,15 +78,15 @@
                 DataType.A_FLOAT32,
                 DataType.A_FLOAT64,
         ]:
             extracted_bytes = extracted_bytes[::-1]
 
         padding = (8 - (bit_length + self.cursor_bit_position) % 8) % 8
         internal_value, = bitstruct.unpack_from(
-            f"{ODX_TYPE_TO_FORMAT_LETTER[base_data_type]}{bit_length}",
+            f"{base_data_type.bitstruct_format_letter}{bit_length}",
             extracted_bytes,
             offset=padding)
 
         text_errors = 'strict' if exceptions.strict_mode else 'replace'
         if base_data_type == DataType.A_ASCIISTRING:
             assert isinstance(internal_value, (bytes, bytearray))
             # The spec says ASCII, meaning only byte values 0-127.
```

## odxtools/diagcodedtype.py

```diff
@@ -1,23 +1,18 @@
 # SPDX-License-Identifier: MIT
 import abc
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, Any, Dict, Literal, Optional, Union, cast
+from typing import TYPE_CHECKING, Any, Dict, Literal, Optional, Union
 
-from .decodestate import ODX_TYPE_TO_FORMAT_LETTER, DecodeState
+from .decodestate import DecodeState
 from .encodestate import EncodeState
-from .exceptions import EncodeError, odxassert, odxraise
+from .exceptions import odxassert, odxraise
 from .odxlink import OdxLinkDatabase, OdxLinkId
 from .odxtypes import AtomicOdxType, DataType
 
-try:
-    import bitstruct.c as bitstruct
-except ImportError:
-    import bitstruct
-
 if TYPE_CHECKING:
     from .diaglayer import DiagLayer
 
 # Allowed diag-coded types
 DctType = Literal[
     "LEADING-LENGTH-INFO-TYPE",
     "MIN-MAX-LENGTH-TYPE",
@@ -52,96 +47,14 @@
     def dct_type(self) -> DctType:
         pass
 
     @property
     def is_highlow_byte_order(self) -> bool:
         return self.is_highlow_byte_order_raw in [None, True]
 
-    @staticmethod
-    def _encode_internal_value(
-        internal_value: AtomicOdxType,
-        bit_position: int,
-        bit_length: int,
-        base_data_type: DataType,
-        is_highlow_byte_order: bool,
-    ) -> bytes:
-        """Convert the internal_value to bytes."""
-        # Check that bytes and strings actually fit into the bit length
-        if base_data_type == DataType.A_BYTEFIELD:
-            if isinstance(internal_value, bytearray):
-                internal_value = bytes(internal_value)
-            if not isinstance(internal_value, bytes):
-                odxraise()
-            if 8 * len(internal_value) > bit_length:
-                raise EncodeError(f"The bytefield {internal_value.hex()} is too large "
-                                  f"({len(internal_value)} bytes)."
-                                  f" The maximum length is {bit_length//8}.")
-        if base_data_type == DataType.A_ASCIISTRING:
-            if not isinstance(internal_value, str):
-                odxraise()
-
-            # The spec says ASCII, meaning only byte values 0-127.
-            # But in practice, vendors use iso-8859-1, aka latin-1
-            # reason being iso-8859-1 never fails since it has a valid
-            # character mapping for every possible byte sequence.
-            internal_value = internal_value.encode("iso-8859-1")
-
-            if 8 * len(internal_value) > bit_length:
-                raise EncodeError(f"The string {repr(internal_value)} is too large."
-                                  f" The maximum number of characters is {bit_length//8}.")
-        elif base_data_type == DataType.A_UTF8STRING:
-            if not isinstance(internal_value, str):
-                odxraise()
-
-            internal_value = internal_value.encode("utf-8")
-
-            if 8 * len(internal_value) > bit_length:
-                raise EncodeError(f"The string {repr(internal_value)} is too large."
-                                  f" The maximum number of bytes is {bit_length//8}.")
-
-        elif base_data_type == DataType.A_UNICODE2STRING:
-            if not isinstance(internal_value, str):
-                odxraise()
-
-            text_encoding = "utf-16-be" if is_highlow_byte_order else "utf-16-le"
-            internal_value = internal_value.encode(text_encoding)
-
-            if 8 * len(internal_value) > bit_length:
-                raise EncodeError(f"The string {repr(internal_value)} is too large."
-                                  f" The maximum number of characters is {bit_length//16}.")
-
-        # If the bit length is zero, return empty bytes
-        if bit_length == 0:
-            if (base_data_type.value in [
-                    DataType.A_INT32, DataType.A_UINT32, DataType.A_FLOAT32, DataType.A_FLOAT64
-            ] and base_data_type.value != 0):
-                raise EncodeError(
-                    f"The number {repr(internal_value)} cannot be encoded into {bit_length} bits.")
-            return b''
-
-        char = ODX_TYPE_TO_FORMAT_LETTER[base_data_type]
-        padding = (8 - ((bit_length + bit_position) % 8)) % 8
-        odxassert((0 <= padding and padding < 8 and (padding + bit_length + bit_position) % 8 == 0),
-                  f"Incorrect padding {padding}")
-        left_pad = f"p{padding}" if padding > 0 else ""
-
-        # actually encode the value
-        coded = bitstruct.pack(f"{left_pad}{char}{bit_length}", internal_value)
-
-        # apply byte order for numeric objects
-        if not is_highlow_byte_order and base_data_type in [
-                DataType.A_INT32,
-                DataType.A_UINT32,
-                DataType.A_FLOAT32,
-                DataType.A_FLOAT64,
-        ]:
-            coded = coded[::-1]
-
-        return cast(bytes, coded)
-
     def _minimal_byte_length_of(self, internal_value: Union[bytes, str]) -> int:
         """Helper method to get the minimal byte length.
         (needed for LeadingLength- and MinMaxLengthType)
         """
         byte_length: int = -1
         # A_BYTEFIELD, A_ASCIISTRING, A_UNICODE2STRING, A_UTF8STRING
         if self.base_data_type == DataType.A_BYTEFIELD:
@@ -156,34 +69,33 @@
             if not isinstance(internal_value, str):
                 odxraise()
 
             byte_length = len(bytes(internal_value, "utf-16-le"))
             odxassert(
                 byte_length % 2 == 0, f"The bit length of A_UNICODE2STRING must"
                 f" be a multiple of 16 but is {8*byte_length}")
+
         return byte_length
 
-    @abc.abstractmethod
-    def convert_internal_to_bytes(self, internal_value: AtomicOdxType, encode_state: EncodeState,
-                                  bit_position: int) -> bytes:
+    def encode_into_pdu(self, internal_value: AtomicOdxType, encode_state: EncodeState) -> None:
         """Encode the internal value.
 
         Parameters
         ----------
         internal_value : python type corresponding to self.base_data_type
             the value to be encoded
         bit_position : int
 
         length_keys : Dict[OdxLinkId, int]
             mapping from ID (of the length key) to bit length
             (only needed for ParamLengthInfoType)
         """
-        pass
+        raise NotImplementedError(
+            f".encode_into_pdu() is not implemented by the class {type(self).__name__}")
 
-    @abc.abstractmethod
     def decode_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
         """Decode the parameter value from the coded message.
 
         Parameters
         ----------
         decode_state : DecodeState
             The decoding state
@@ -191,8 +103,9 @@
         Returns
         -------
         str or int or bytes or dict
             the decoded parameter value
         int
             the next byte position after the extracted parameter
         """
-        pass
+        raise NotImplementedError(
+            f".decode_from_pdu() is not implemented by the class {type(self).__name__}")
```

## odxtools/diaglayer.py

```diff
@@ -1,10 +1,11 @@
 # SPDX-License-Identifier: MIT
 import re
 import warnings
+from copy import copy
 from dataclasses import dataclass
 from functools import cached_property
 from itertools import chain
 from typing import Any, Callable, Dict, Iterable, List, Optional, Tuple, TypeVar, Union, cast
 from xml.etree import ElementTree
 
 from deprecation import deprecated
@@ -72,14 +73,58 @@
         result[self.odx_id] = self
 
         return result
 
     def _resolve_odxlinks(self, odxlinks: OdxLinkDatabase) -> None:
         """Recursively resolve all references."""
 
+        # deal with the import references: these basically extend the
+        # pool of objects that are referenceable without having to
+        # explicitly specify the DOCREF attribute in the
+        # reference. This mechanism can thus be seen as a kind of
+        # "poor man's inheritance".
+        if self.import_refs:
+            imported_links: Dict[OdxLinkId, Any] = {}
+            for import_ref in self.import_refs:
+                imported_dl = odxlinks.resolve(import_ref, DiagLayer)
+
+                odxassert(
+                    imported_dl.variant_type == DiagLayerType.ECU_SHARED_DATA,
+                    f"Tried to import references from diagnostic layer "
+                    f"'{imported_dl.short_name}' of type {imported_dl.variant_type.value}. "
+                    f"Only ECU-SHARED-DATA layers may be referenced using the "
+                    f"IMPORT-REF mechanism")
+
+                # TODO: ensure that the imported diagnostic layer has
+                # not been referenced in any PARENT-REF of the current
+                # layer or any of its parents.
+
+                # TODO: detect and complain about cyclic IMPORT-REFs
+
+                # TODO (?): detect conflicts with locally-defined
+                # objects
+
+                imported_dl_links = imported_dl._build_odxlinks()
+                for link_id, obj in imported_dl_links.items():
+                    # the imported objects shall behave as if they
+                    # were defined by the importing layer. IOW, they
+                    # must be visible in the same document fragments.
+                    link_id = OdxLinkId(link_id.local_id, self.odx_id.doc_fragments)
+                    imported_links[link_id] = obj
+
+            # We need to copy the odxlink database here since this
+            # function must not modify its argument because the
+            # imported references only apply within this specific
+            # diagnostic layer
+            extended_odxlinks = copy(odxlinks)
+            extended_odxlinks.update(imported_links)
+
+            self.diag_layer_raw._resolve_odxlinks(extended_odxlinks)
+            return
+
         self.diag_layer_raw._resolve_odxlinks(odxlinks)
 
     def _finalize_init(self, odxlinks: OdxLinkDatabase) -> None:
         """This method deals with everything inheritance related and
         -- after the final set of objects covered by the diagnostic
         layer is determined -- resolves any short name references in
         the diagnostic layer.
```

## odxtools/diagservice.py

```diff
@@ -211,50 +211,46 @@
             raise RuntimeError(f"Expected a set of decoded parameters, got {type(param_dict)}")
         return Message(
             coded_message=raw_message,
             service=self,
             coding_object=coding_object,
             param_dict=param_dict)
 
-    def encode_request(self, **params: ParameterValue) -> bytes:
+    def encode_request(self, **kwargs: ParameterValue) -> bytes:
         """
-        Composes an UDS request as list of bytes for this service.
-        Parameters:
-        ----------
-        params: dict
-            Parameters of the RPC as mapping from SHORT-NAME of the parameter to the physical value
+        Composes an UDS request an array of bytes for this service.
         """
         # make sure that all parameters which are required for
         # encoding are specified (parameters which have a default are
         # optional)
         if self.request is None:
             return b''
 
         missing_params = {x.short_name
-                          for x in self.request.required_parameters}.difference(params.keys())
+                          for x in self.request.required_parameters}.difference(kwargs.keys())
         odxassert(
             len(missing_params) == 0, f"The parameters {missing_params} are required but missing!")
 
         # make sure that no unknown parameters are specified
         rq_all_param_names = {x.short_name for x in self.request.parameters}
         odxassert(
-            set(params.keys()).issubset(rq_all_param_names),
-            f"Unknown parameters specified for encoding: {params.keys()}, "
+            set(kwargs.keys()).issubset(rq_all_param_names),
+            f"Unknown parameters specified for encoding: {kwargs.keys()}, "
             f"known parameters are: {rq_all_param_names}")
-        return self.request.encode(coded_request=None, **params)
+        return self.request.encode(**kwargs)
 
     def encode_positive_response(self,
                                  coded_request: bytes,
                                  response_index: int = 0,
-                                 **params: ParameterValue) -> bytes:
+                                 **kwargs: ParameterValue) -> bytes:
         # TODO: Should the user decide the positive response or what are the differences?
-        return self.positive_responses[response_index].encode(coded_request, **params)
+        return self.positive_responses[response_index].encode(coded_request, **kwargs)
 
     def encode_negative_response(self,
                                  coded_request: bytes,
                                  response_index: int = 0,
-                                 **params: ParameterValue) -> bytes:
-        return self.negative_responses[response_index].encode(coded_request, **params)
+                                 **kwargs: ParameterValue) -> bytes:
+        return self.negative_responses[response_index].encode(coded_request, **kwargs)
 
-    def __call__(self, **params: ParameterValue) -> bytes:
+    def __call__(self, **kwargs: ParameterValue) -> bytes:
         """Encode a request."""
-        return self.encode_request(**params)
+        return self.encode_request(**kwargs)
```

## odxtools/dopbase.py

```diff
@@ -17,15 +17,16 @@
     from .diaglayer import DiagLayer
 
 
 @dataclass
 class DopBase(IdentifiableElement):
     """Base class for all DOPs.
 
-    Any class that a parameter can reference via a DOP-REF should inherit from this class.
+    Any class that a parameter can reference via a DOP-REF should
+    inherit from this class.
     """
 
     admin_data: Optional[AdminData]
     sdgs: List[SpecialDataGroup]
 
     @staticmethod
     def from_et(et_element: ElementTree.Element, doc_frags: List[OdxDocFragment]) -> "DopBase":
@@ -56,21 +57,17 @@
         for sdg in self.sdgs:
             sdg._resolve_snrefs(diag_layer)
 
     def get_static_bit_length(self) -> Optional[int]:
         return None
 
     def is_valid_physical_value(self, physical_value: ParameterValue) -> bool:
-        """Determine if a phyical value can be handled by the DOP
-        """
+        """Determine if a phyical value can be handled by the DOP"""
         raise NotImplementedError
 
-    def convert_physical_to_bytes(self,
-                                  physical_value: ParameterValue,
-                                  encode_state: EncodeState,
-                                  bit_position: int = 0) -> bytes:
-        """Convert the physical value into bytes."""
+    def encode_into_pdu(self, physical_value: ParameterValue, encode_state: EncodeState) -> None:
+        """Convert the physical value to bytes and emplace them into a PDU."""
         raise NotImplementedError
 
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         """Extract the bytes from the PDU and convert them to the physical value."""
         raise NotImplementedError
```

## odxtools/dtcdop.py

```diff
@@ -1,22 +1,24 @@
 # SPDX-License-Identifier: MIT
 # from dataclasses import dataclass, field
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, List, Optional, Union, cast
 from xml.etree import ElementTree
 
+from typing_extensions import override
+
 from .compumethods.compumethod import CompuMethod
 from .compumethods.createanycompumethod import create_any_compu_method_from_et
 from .createanydiagcodedtype import create_any_diag_coded_type_from_et
 from .decodestate import DecodeState
 from .diagcodedtype import DiagCodedType
 from .diagnostictroublecode import DiagnosticTroubleCode
 from .dopbase import DopBase
 from .encodestate import EncodeState
-from .exceptions import DecodeError, EncodeError, odxassert, odxrequire
+from .exceptions import DecodeError, EncodeError, odxassert, odxraise, odxrequire
 from .nameditemlist import NamedItemList
 from .odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId, OdxLinkRef
 from .odxtypes import ParameterValue, odxstr_to_bool
 from .physicaltype import PhysicalType
 from .utils import dataclass_fields_asdict
 
 if TYPE_CHECKING:
@@ -83,59 +85,61 @@
     def is_visible(self) -> bool:
         return self.is_visible_raw is True
 
     @property
     def linked_dtc_dops(self) -> NamedItemList["DtcDop"]:
         return self._linked_dtc_dops
 
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
 
         int_trouble_code = self.diag_coded_type.decode_from_pdu(decode_state)
 
-        if self.compu_method.is_valid_internal_value(int_trouble_code):
-            trouble_code = self.compu_method.convert_internal_to_physical(int_trouble_code)
-        else:
+        if not self.compu_method.is_valid_internal_value(int_trouble_code):
             # TODO: How to prevent this?
-            raise DecodeError(
+            odxraise(
                 f"DTC-DOP {self.short_name} could not convert the coded value "
-                f" {repr(int_trouble_code)} to physical type {self.physical_type.base_data_type}.")
+                f" {repr(int_trouble_code)} to physical type {self.physical_type.base_data_type}.",
+                DecodeError)
+            return
+
+        trouble_code = self.compu_method.convert_internal_to_physical(int_trouble_code)
 
         assert isinstance(trouble_code, int)
 
         dtcs = [x for x in self.dtcs if x.trouble_code == trouble_code]
 
         odxassert(len(dtcs) < 2, f"Multiple matching DTCs for trouble code 0x{trouble_code:06x}")
 
         if len(dtcs) == 1:
             # we found exactly one described DTC
             return dtcs[0]
 
         # the DTC was not specified. This probably means that the
-        # diagnostic description file is incomplete. We do not bail
-        # out but we cannot provide an interpretation for it out of the
-        # box...
-        dtc = DiagnosticTroubleCode(
+        # diagnostic description file is incomplete.
+        odxraise(
+            f"Encountered DTC 0x{trouble_code:06x} which has not been defined "
+            f"by the database", DecodeError)
+
+        return DiagnosticTroubleCode(
             trouble_code=trouble_code,
             odx_id=cast(OdxLinkId, None),
             short_name=f'DTC_{trouble_code:06x}',
             long_name=None,
             description=None,
             text=None,
             display_trouble_code=None,
             level=None,
             is_temporary_raw=None,
             sdgs=[],
         )
 
-        return dtc
-
-    def convert_physical_to_bytes(self,
-                                  physical_value: ParameterValue,
-                                  encode_state: EncodeState,
-                                  bit_position: int = 0) -> bytes:
+    @override
+    def encode_into_pdu(self, physical_value: Optional[ParameterValue],
+                        encode_state: EncodeState) -> None:
         if isinstance(physical_value, DiagnosticTroubleCode):
             trouble_code = physical_value.trouble_code
         elif isinstance(physical_value, int):
             # assume that physical value is the trouble_code
             trouble_code = physical_value
         elif isinstance(physical_value, str):
             # assume that physical value is the short_name
@@ -143,17 +147,15 @@
             odxassert(len(dtcs) == 1)
             trouble_code = dtcs[0].trouble_code
         else:
             raise EncodeError(f"The DTC-DOP {self.short_name} expected a"
                               f" DiagnosticTroubleCode but got {physical_value!r}.")
 
         internal_trouble_code = self.compu_method.convert_physical_to_internal(trouble_code)
-
-        return self.diag_coded_type.convert_internal_to_bytes(
-            internal_trouble_code, encode_state=encode_state, bit_position=bit_position)
+        self.diag_coded_type.encode_into_pdu(internal_trouble_code, encode_state)
 
     def _build_odxlinks(self) -> Dict[OdxLinkId, Any]:
         odxlinks = super()._build_odxlinks()
 
         for dtc_proxy in self.dtcs_raw:
             if isinstance(dtc_proxy, DiagnosticTroubleCode):
                 odxlinks.update(dtc_proxy._build_odxlinks())
```

## odxtools/dynamiclengthfield.py

```diff
@@ -1,12 +1,14 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, List
 from xml.etree import ElementTree
 
+from typing_extensions import override
+
 from .decodestate import DecodeState
 from .determinenumberofitems import DetermineNumberOfItems
 from .encodestate import EncodeState
 from .exceptions import DecodeError, EncodeError, odxassert, odxraise, odxrequire
 from .field import Field
 from .odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
 from .odxtypes import ParameterValue
@@ -43,52 +45,54 @@
         super()._resolve_odxlinks(odxlinks)
         self.determine_number_of_items._resolve_odxlinks(odxlinks)
 
     def _resolve_snrefs(self, diag_layer: "DiagLayer") -> None:
         super()._resolve_snrefs(diag_layer)
         self.determine_number_of_items._resolve_snrefs(diag_layer)
 
-    def convert_physical_to_bytes(
-        self,
-        physical_value: ParameterValue,
-        encode_state: EncodeState,
-        bit_position: int = 0,
-    ) -> bytes:
+    @override
+    def encode_into_pdu(self, physical_value: ParameterValue, encode_state: EncodeState) -> None:
+
+        odxassert(encode_state.cursor_bit_position == 0,
+                  "No bit position can be specified for dynamic length fields!")
 
-        odxassert(bit_position == 0, "No bit position can be specified for dynamic length fields!")
         if not isinstance(physical_value, list):
             odxraise(
                 f"Expected a list of values for dynamic length field {self.short_name}, "
                 f"got {type(physical_value)}", EncodeError)
 
+        # move the origin to the cursor position
+        orig_cursor = encode_state.cursor_byte_position
+        orig_origin = encode_state.origin_byte_position
+        encode_state.origin_byte_position = encode_state.cursor_byte_position
+
         det_num_items = self.determine_number_of_items
-        field_len = det_num_items.dop.convert_physical_to_bytes(
-            len(physical_value), encode_state, det_num_items.bit_position or 0)
+        encode_state.cursor_bit_position = self.determine_number_of_items.bit_position or 0
+        encode_state.cursor_byte_position = encode_state.origin_byte_position + det_num_items.byte_position
+        det_num_items.dop.encode_into_pdu(len(physical_value), encode_state)
 
-        # hack to emplace the length specifier at the correct location
-        tmp = encode_state.coded_message
-        encode_state.coded_message = bytearray()
-        encode_state.emplace_atomic_value(field_len, self.short_name + ".num_items",
-                                          det_num_items.byte_position)
-        result = encode_state.coded_message
-        encode_state.coded_message = tmp
-
-        # if required, add padding between the length specifier and
-        # the first item
-        if len(result) < self.offset:
-            result.extend([0] * (self.offset - len(result)))
-        elif len(result) > self.offset:
+        if encode_state.cursor_byte_position - encode_state.origin_byte_position > self.offset:
             odxraise(f"The length specifier of field {self.short_name} overlaps "
-                     f"with the first item!")
+                     f"with its first item!")
+
+        encode_state.cursor_byte_position = encode_state.origin_byte_position + self.offset
+        encode_state.cursor_bit_position = 0
 
         for value in physical_value:
-            result += self.structure.convert_physical_to_bytes(value, encode_state)
+            self.structure.encode_into_pdu(value, encode_state)
+
+        # ensure the correct message size if the field is empty
+        if len(physical_value) == 0:
+            encode_state.emplace_bytes(b"")
 
-        return result
+        # move cursor and origin positions
+        encode_state.origin_byte_position = orig_origin
+        encode_state.cursor_byte_position = max(orig_cursor, encode_state.cursor_byte_position)
 
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
 
         odxassert(decode_state.cursor_bit_position == 0,
                   "No bit position can be specified for dynamic length fields!")
 
         orig_origin = decode_state.origin_byte_position
         orig_cursor = decode_state.cursor_byte_position
```

## odxtools/encodestate.py

```diff
@@ -1,58 +1,223 @@
 # SPDX-License-Identifier: MIT
 import warnings
 from dataclasses import dataclass, field
-from typing import TYPE_CHECKING, Any, Dict, Optional
+from typing import Dict, Optional
 
-from .exceptions import OdxWarning
+from .exceptions import EncodeError, OdxWarning, odxassert, odxraise
+from .odxtypes import AtomicOdxType, DataType
 
-if TYPE_CHECKING:
-    from .tablerow import TableRow
+try:
+    import bitstruct.c as bitstruct
+except ImportError:
+    import bitstruct
 
 
 @dataclass
 class EncodeState:
     """Utility class to holding the state variables needed for encoding a message.
     """
 
     #: payload that has been constructed so far
-    coded_message: bytearray
+    coded_message: bytearray = field(default_factory=bytearray)
 
-    #: a mapping from short name to value for each parameter
-    parameter_values: Dict[str, Any]
+    #: the bits of the payload that are used
+    used_mask: bytearray = field(default_factory=bytearray)
+
+    #: The absolute position in bytes from the beginning of the PDU to
+    #: which relative positions refer to, e.g., the beginning of the
+    #: structure.
+    origin_byte_position: int = 0
+
+    #: The absolute position in bytes from the beginning of the PDU
+    #: where the next object ought to be placed into the PDU
+    cursor_byte_position: int = 0
+
+    #: The bit position [0-7] where the next object ought to be
+    #: placed into the PDU
+    cursor_bit_position: int = 0
 
     #: If encoding a response: request that triggered the response
     triggering_request: Optional[bytes] = None
 
     #: Mapping from the short name of a length-key parameter to bit
     #: lengths (specified by LengthKeyParameter)
     length_keys: Dict[str, int] = field(default_factory=dict)
 
     #: Mapping from the short name of a table-key parameter to the
-    #: corresponding row of the table (specified by TableKeyParameter)
-    table_keys: Dict[str, "TableRow"] = field(default_factory=dict)
+    #: short name of the corresponding row of the table (specified by
+    #: TableKeyParameter)
+    table_keys: Dict[str, str] = field(default_factory=dict)
+
+    #: The cursor position where a given length- or table key is located
+    #: in the PDU
+    key_pos: Dict[str, int] = field(default_factory=dict)
 
     #: Flag whether we are currently the last parameter of the PDU
-    #: (needed for MinMaxLengthType)
-    is_end_of_pdu: bool = False
+    #: (needed for MinMaxLengthType, EndOfPduField, etc.)
+    is_end_of_pdu: bool = True
+
+    def __post_init__(self) -> None:
+        # if a coded message has been specified, but no used_mask, we
+        # assume that all of the bits of the coded message are
+        # currently used.
+        if len(self.coded_message) > len(self.used_mask):
+            self.used_mask += b'\xff' * (len(self.coded_message) - len(self.used_mask))
+        if len(self.coded_message) < len(self.used_mask):
+            odxraise(f"The specified bit mask 0x{self.used_mask.hex()} for used bits "
+                     f"is not suitable for representing the coded_message "
+                     f"0x{self.coded_message.hex()}")
+            self.used_mask = self.used_mask[:len(self.coded_message)]
+
+    def emplace_atomic_value(
+        self,
+        *,
+        internal_value: AtomicOdxType,
+        bit_length: int,
+        base_data_type: DataType,
+        is_highlow_byte_order: bool,
+        used_mask: Optional[bytes],
+    ) -> None:
+        """Convert the internal_value to bytes and emplace this into the PDU"""
+
+        raw_value: AtomicOdxType
+
+        # Check that bytes and strings actually fit into the bit length
+        if base_data_type == DataType.A_BYTEFIELD:
+            if not isinstance(internal_value, bytes):
+                odxraise()
+            if 8 * len(internal_value) > bit_length:
+                raise EncodeError(f"The bytefield {internal_value.hex()} is too large "
+                                  f"({len(internal_value)} bytes)."
+                                  f" The maximum length is {bit_length//8}.")
+            raw_value = internal_value
+        elif base_data_type == DataType.A_ASCIISTRING:
+            if not isinstance(internal_value, str):
+                odxraise()
+
+            # The spec says ASCII, meaning only byte values 0-127.
+            # But in practice, vendors use iso-8859-1, aka latin-1
+            # reason being iso-8859-1 never fails since it has a valid
+            # character mapping for every possible byte sequence.
+            raw_value = internal_value.encode("iso-8859-1")
+
+            if 8 * len(raw_value) > bit_length:
+                raise EncodeError(f"The string {repr(internal_value)} is too large."
+                                  f" The maximum number of characters is {bit_length//8}.")
+        elif base_data_type == DataType.A_UTF8STRING:
+            if not isinstance(internal_value, str):
+                odxraise()
+
+            raw_value = internal_value.encode("utf-8")
+
+            if 8 * len(raw_value) > bit_length:
+                raise EncodeError(f"The string {repr(internal_value)} is too large."
+                                  f" The maximum number of bytes is {bit_length//8}.")
+
+        elif base_data_type == DataType.A_UNICODE2STRING:
+            if not isinstance(internal_value, str):
+                odxraise()
+
+            text_encoding = "utf-16-be" if is_highlow_byte_order else "utf-16-le"
+            raw_value = internal_value.encode(text_encoding)
+
+            if 8 * len(raw_value) > bit_length:
+                raise EncodeError(f"The string {repr(internal_value)} is too large."
+                                  f" The maximum number of characters is {bit_length//16}.")
+        else:
+            raw_value = internal_value
+
+        # If the bit length is zero, return empty bytes
+        if bit_length == 0:
+            if (base_data_type.value in [
+                    DataType.A_INT32, DataType.A_UINT32, DataType.A_FLOAT32, DataType.A_FLOAT64
+            ] and base_data_type.value != 0):
+                odxraise(
+                    f"The number {repr(internal_value)} cannot be encoded into {bit_length} bits.",
+                    EncodeError)
+            self.emplace_bytes(b'')
+            return
+
+        char = base_data_type.bitstruct_format_letter
+        padding = (8 - ((bit_length + self.cursor_bit_position) % 8)) % 8
+        odxassert((0 <= padding and padding < 8 and
+                   (padding + bit_length + self.cursor_bit_position) % 8 == 0),
+                  f"Incorrect padding {padding}")
+        left_pad = f"p{padding}" if padding > 0 else ""
+
+        # actually encode the value
+        coded = bitstruct.pack(f"{left_pad}{char}{bit_length}", raw_value)
+
+        # create the raw mask of used bits for numeric objects
+        used_mask_raw = used_mask
+        if base_data_type in [DataType.A_INT32, DataType.A_UINT32
+                             ] and (self.cursor_bit_position != 0 or
+                                    (self.cursor_bit_position + bit_length) % 8 != 0):
+            if used_mask is None:
+                tmp = (1 << bit_length) - 1
+            else:
+                tmp = int.from_bytes(used_mask, "big")
+            tmp <<= self.cursor_bit_position
+
+            used_mask_raw = tmp.to_bytes((self.cursor_bit_position + bit_length + 7) // 8, "big")
+
+        # apply byte order to numeric objects
+        if not is_highlow_byte_order and base_data_type in [
+                DataType.A_INT32, DataType.A_UINT32, DataType.A_FLOAT32, DataType.A_FLOAT64
+        ]:
+            coded = coded[::-1]
+
+            if used_mask_raw is not None:
+                used_mask_raw = used_mask_raw[::-1]
+
+        self.cursor_bit_position = 0
+        self.emplace_bytes(coded, obj_used_mask=used_mask_raw)
+
+    def emplace_bytes(self,
+                      new_data: bytes,
+                      obj_name: Optional[str] = None,
+                      obj_used_mask: Optional[bytes] = None) -> None:
+        if self.cursor_bit_position != 0:
+            odxraise("EncodeState.emplace_bytes can only be called "
+                     "for a bit position of 0!", RuntimeError)
 
-    def emplace_atomic_value(self,
-                             new_data: bytes,
-                             param_name: str,
-                             pos: Optional[int] = None) -> None:
-        if pos is None:
-            pos = len(self.coded_message)
+        pos = self.cursor_byte_position
 
         # Make blob longer if necessary
         min_length = pos + len(new_data)
         if len(self.coded_message) < min_length:
-            self.coded_message.extend([0] * (min_length - len(self.coded_message)))
+            pad = b'\x00' * (min_length - len(self.coded_message))
+            self.coded_message += pad
+            self.used_mask += pad
+
+        if obj_used_mask is None:
+            # Happy path for when no obj_used_mask has been
+            # specified. In this case we assume that all bits of the
+            # new data to be emplaced are used.
+            n = len(new_data)
 
-        for byte_idx_val, byte_idx_rpc in enumerate(range(pos, pos + len(new_data))):
-            # insert byte value
-            if self.coded_message[byte_idx_rpc] & new_data[byte_idx_val] != 0:
+            if self.used_mask[pos:pos + n] != b'\x00' * n:
                 warnings.warn(
-                    f"Object '{param_name}' overlaps with another parameter (bytes are already set)",
+                    f"Overlapping objects detected in between bytes {pos} and "
+                    f"{pos+n}",
                     OdxWarning,
                     stacklevel=1,
                 )
-            self.coded_message[byte_idx_rpc] |= new_data[byte_idx_val]
+            self.coded_message[pos:pos + n] = new_data
+            self.used_mask[pos:pos + n] = b'\xff' * n
+        else:
+            # insert data the hard way, i.e. we have to look at each
+            # individual byte to determine if it has already been used
+            # somewhere else (it would be nice if bytearrays supported
+            # bitwise operations!)
+            for i in range(len(new_data)):
+                if self.used_mask[pos + i] & obj_used_mask[i] != 0:
+                    warnings.warn(
+                        f"Overlapping objects detected at position {pos + i}",
+                        OdxWarning,
+                        stacklevel=1,
+                    )
+                self.coded_message[pos + i] &= ~obj_used_mask[i]
+                self.coded_message[pos + i] |= new_data[i] & obj_used_mask[i]
+                self.used_mask[pos + i] |= obj_used_mask[i]
+
+        self.cursor_byte_position += len(new_data)
```

## odxtools/endofpdufield.py

```diff
@@ -1,12 +1,14 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import List, Optional
 from xml.etree import ElementTree
 
+from typing_extensions import override
+
 from .decodestate import DecodeState
 from .encodestate import EncodeState
 from .exceptions import EncodeError, odxassert, odxraise
 from .field import Field
 from .odxlink import OdxDocFragment
 from .odxtypes import ParameterValue
 from .utils import dataclass_fields_asdict
@@ -35,34 +37,30 @@
         eopf = EndOfPduField(
             min_number_of_items=min_number_of_items,
             max_number_of_items=max_number_of_items,
             **kwargs)
 
         return eopf
 
-    def convert_physical_to_bytes(
-        self,
-        physical_value: ParameterValue,
-        encode_state: EncodeState,
-        bit_position: int = 0,
-    ) -> bytes:
-
-        odxassert(
-            bit_position == 0, "End of PDU field must be byte aligned. "
-            "Is there an error in reading the .odx?", EncodeError)
+    @override
+    def encode_into_pdu(self, physical_value: Optional[ParameterValue],
+                        encode_state: EncodeState) -> None:
+        odxassert(not encode_state.cursor_bit_position,
+                  "No bit position can be specified for end-of-pdu fields!")
+
         if not isinstance(physical_value, list):
             odxraise(
-                f"Expected a list of values for end-of-pdu field {self.short_name}, "
-                f"got {type(physical_value)}", EncodeError)
+                f"Invalid type {type(physical_value).__name__} of physical "
+                f"value for end-of-pdu field, expected a list", EncodeError)
+            return
 
-        coded_message = b''
         for value in physical_value:
-            coded_message += self.structure.convert_physical_to_bytes(value, encode_state)
-        return coded_message
+            self.structure.encode_into_pdu(value, encode_state)
 
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         odxassert(not decode_state.cursor_bit_position,
                   "No bit position can be specified for end-of-pdu fields!")
 
         result: List[ParameterValue] = []
         while decode_state.cursor_byte_position < len(decode_state.coded_message):
             # ATTENTION: the ODX specification is very misleading
```

## odxtools/environmentdatadescription.py

```diff
@@ -1,17 +1,19 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple
+from typing import TYPE_CHECKING, Any, Dict, List, Optional
 from xml.etree import ElementTree
 
+from typing_extensions import override
+
 from .complexdop import ComplexDop
 from .decodestate import DecodeState
 from .encodestate import EncodeState
 from .environmentdata import EnvironmentData
-from .exceptions import DecodeError, EncodeError, odxrequire
+from .exceptions import odxraise, odxrequire
 from .odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId, OdxLinkRef
 from .odxtypes import ParameterValue
 from .utils import dataclass_fields_asdict
 
 if TYPE_CHECKING:
     from .diaglayer import DiagLayer
 
@@ -82,27 +84,25 @@
     def _resolve_snrefs(self, diag_layer: "DiagLayer") -> None:
         # ODX 2.0 specifies environment data objects here, ODX 2.2
         # uses references
         if self.env_data_refs:
             for ed in self.env_datas:
                 ed._resolve_snrefs(diag_layer)
 
-    def convert_physical_to_bytes(self,
-                                  physical_value: ParameterValue,
-                                  encode_state: EncodeState,
-                                  bit_position: int = 0) -> bytes:
-        """Convert the physical value into bytes.
+    @override
+    def encode_into_pdu(self, physical_value: Optional[ParameterValue],
+                        encode_state: EncodeState) -> None:
+        """Convert a physical value into bytes and emplace them into a PDU.
 
         Since environmental data is supposed to never appear on the
         wire, this method just raises an EncodeError exception.
         """
-        raise EncodeError("EnvironmentDataDescription DOPs cannot be encoded or decoded")
+        odxraise("EnvironmentDataDescription DOPs cannot be encoded or decoded")
 
-    def convert_bytes_to_physical(self,
-                                  decode_state: DecodeState,
-                                  bit_position: int = 0) -> Tuple[ParameterValue, int]:
-        """Extract the bytes from the PDU and convert them to the physical value.
+    @override
+    def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
+        """Extract the bytes from a PDU and convert them to a physical value.
 
         Since environmental data is supposed to never appear on the
         wire, this method just raises an DecodeError exception.
         """
-        raise DecodeError("EnvironmentDataDescription DOPs cannot be encoded or decoded")
+        odxraise("EnvironmentDataDescription DOPs cannot be encoded or decoded")
```

## odxtools/leadinglengthinfotype.py

```diff
@@ -1,15 +1,17 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import Any, Optional
+from typing import Optional
+
+from typing_extensions import override
 
 from .decodestate import DecodeState
 from .diagcodedtype import DctType, DiagCodedType
 from .encodestate import EncodeState
-from .exceptions import odxassert, odxraise
+from .exceptions import EncodeError, odxassert, odxraise
 from .odxtypes import AtomicOdxType, DataType
 
 
 @dataclass
 class LeadingLengthInfoType(DiagCodedType):
     #: bit length of the length specifier field
     #:
@@ -38,37 +40,48 @@
     def get_static_bit_length(self) -> Optional[int]:
         # note that self.bit_length is just the length of the length
         # specifier field. This is then followed by the same number of
         # bytes as the value of this field, i.e., the length of this
         # DCT is dynamic!
         return None
 
-    def convert_internal_to_bytes(self, internal_value: Any, encode_state: EncodeState,
-                                  bit_position: int) -> bytes:
+    @override
+    def encode_into_pdu(self, internal_value: AtomicOdxType, encode_state: EncodeState) -> None:
+
+        if not isinstance(internal_value, (str, bytes)):
+            odxraise(
+                f"LEADING-LENGTH-INFO types can only be used for strings and byte fields, "
+                f"not {type(internal_value).__name__}", EncodeError)
+            return
 
         byte_length = self._minimal_byte_length_of(internal_value)
 
-        length_bytes = self._encode_internal_value(
-            byte_length,
-            bit_position=bit_position,
+        used_mask = None
+        bit_pos = encode_state.cursor_bit_position
+        if encode_state.cursor_bit_position != 0 or (bit_pos + self.bit_length) % 8 != 0:
+            used_mask = (1 << self.bit_length) - 1
+            used_mask <<= bit_pos
+
+        encode_state.emplace_atomic_value(
+            internal_value=byte_length,
+            used_mask=None,
             bit_length=self.bit_length,
             base_data_type=DataType.A_UINT32,
             is_highlow_byte_order=self.is_highlow_byte_order,
         )
 
-        value_bytes = self._encode_internal_value(
-            internal_value,
-            bit_position=0,
+        encode_state.emplace_atomic_value(
+            internal_value=internal_value,
+            used_mask=None,
             bit_length=8 * byte_length,
             base_data_type=self.base_data_type,
             is_highlow_byte_order=self.is_highlow_byte_order,
         )
 
-        return length_bytes + value_bytes
-
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
 
         # Extract length of the parameter value
         byte_length = decode_state.extract_atomic_value(
             bit_length=self.bit_length,
             base_data_type=DataType.A_UINT32,  # length is an integer
             is_highlow_byte_order=self.is_highlow_byte_order,
```

## odxtools/minmaxlengthtype.py

```diff
@@ -1,11 +1,13 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import Optional
 
+from typing_extensions import override
+
 from .decodestate import DecodeState
 from .diagcodedtype import DctType, DiagCodedType
 from .encodestate import EncodeState
 from .exceptions import DecodeError, EncodeError, odxassert, odxraise
 from .odxtypes import AtomicOdxType, DataType
 
 
@@ -47,62 +49,70 @@
         elif self.termination == "HEX-FF":
             if self.base_data_type not in [DataType.A_UNICODE2STRING]:
                 termination_sequence = bytes([0xFF])
             else:
                 termination_sequence = bytes([0xFF, 0xFF])
         return termination_sequence
 
-    def convert_internal_to_bytes(self, internal_value: AtomicOdxType, encode_state: EncodeState,
-                                  bit_position: int) -> bytes:
+    @override
+    def encode_into_pdu(self, internal_value: AtomicOdxType, encode_state: EncodeState) -> None:
+
         if not isinstance(internal_value, (bytes, str)):
             odxraise("MinMaxLengthType is currently only implemented for strings and byte arrays",
                      EncodeError)
 
         if self.max_length is not None:
             data_length = min(len(internal_value), self.max_length)
         else:
             data_length = len(internal_value)
 
-        value_bytes = bytearray(
-            self._encode_internal_value(
-                internal_value,
-                bit_position=0,
-                bit_length=8 * data_length,
-                base_data_type=self.base_data_type,
-                is_highlow_byte_order=self.is_highlow_byte_order,
-            ))
+        orig_cursor = encode_state.cursor_byte_position
+        encode_state.emplace_atomic_value(
+            internal_value=internal_value,
+            used_mask=None,
+            bit_length=8 * data_length,
+            base_data_type=self.base_data_type,
+            is_highlow_byte_order=self.is_highlow_byte_order,
+        )
+        value_len = encode_state.cursor_byte_position - orig_cursor
 
         # TODO: ensure that the termination delimiter is not
         # encountered within the encoded value.
 
-        odxassert(self.termination != "END-OF-PDU" or encode_state.is_end_of_pdu)
-        if encode_state.is_end_of_pdu or len(value_bytes) == self.max_length:
+        odxassert(
+            self.termination != "END-OF-PDU" or encode_state.is_end_of_pdu,
+            "Encountered a MIN-MAX-LENGTH type with END-OF-PDU termination "
+            "which is not located at the end of the PDU")
+        if encode_state.is_end_of_pdu or value_len == self.max_length:
             # All termination types may be ended by the end of the PDU
             # or once reaching the maximum length. In this case, we
             # must not add the termination sequence
             pass
         else:
             termination_sequence = self.__termination_sequence()
 
             # ensure that we don't try to encode an odd-length
             # value when using a two-byte terminator
-            odxassert(len(value_bytes) % len(termination_sequence) == 0)
-
-            value_bytes.extend(termination_sequence)
+            odxassert(value_len % len(termination_sequence) == 0)
 
-        if len(value_bytes) < self.min_length:
-            raise EncodeError(f"Encoded value for MinMaxLengthType "
-                              f"must be at least {self.min_length} bytes long. "
-                              f"(Is: {len(value_bytes)} bytes.)")
-        elif self.max_length is not None and len(value_bytes) > self.max_length:
-            raise EncodeError(f"Encoded value for MinMaxLengthType "
-                              f"must not be longer than {self.max_length} bytes. "
-                              f"(Is: {len(value_bytes)} bytes.)")
+            value_len += len(termination_sequence)
+            encode_state.emplace_bytes(termination_sequence)
 
-        return value_bytes
+        if value_len < self.min_length:
+            odxraise(
+                f"Encoded value for MinMaxLengthType "
+                f"must be at least {self.min_length} bytes long. "
+                f"(Is: {value_len} bytes.)", EncodeError)
+            return
+        elif self.max_length is not None and value_len > self.max_length:
+            odxraise(
+                f"Encoded value for MinMaxLengthType "
+                f"must not be longer than {self.max_length} bytes. "
+                f"(Is: {value_len} bytes.)", EncodeError)
+            return
 
     def decode_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
         odxassert(decode_state.cursor_bit_position == 0,
                   "No bit position can be specified for MIN-MAX-LENGTH-TYPE values.")
         if decode_state.cursor_byte_position + self.min_length > len(decode_state.coded_message):
             raise DecodeError("The PDU ended before minimum length was reached.")
```

## odxtools/multiplexer.py

```diff
@@ -1,12 +1,14 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple
 from xml.etree import ElementTree
 
+from typing_extensions import override
+
 from .complexdop import ComplexDop
 from .decodestate import DecodeState
 from .encodestate import EncodeState
 from .exceptions import DecodeError, EncodeError, odxraise, odxrequire
 from .multiplexercase import MultiplexerCase
 from .multiplexerdefaultcase import MultiplexerDefaultCase
 from .multiplexerswitchkey import MultiplexerSwitchKey
@@ -30,14 +32,15 @@
     byte_position: int
     switch_key: MultiplexerSwitchKey
     default_case: Optional[MultiplexerDefaultCase]
     cases: List[MultiplexerCase]
     is_visible_raw: Optional[bool]
 
     @staticmethod
+    @override
     def from_et(et_element: ElementTree.Element, doc_frags: List[OdxDocFragment]) -> "Multiplexer":
         """Reads a Multiplexer from Diag Layer."""
         base_obj = ComplexDop.from_et(et_element, doc_frags)
         kwargs = dataclass_fields_asdict(base_obj)
 
         byte_position = int(et_element.findtext("BYTE-POSITION", "0"))
         switch_key = MultiplexerSwitchKey.from_et(
@@ -63,58 +66,71 @@
 
     @property
     def is_visible(self) -> bool:
         return self.is_visible_raw is True
 
     def _get_case_limits(self, case: MultiplexerCase) -> Tuple[AtomicOdxType, AtomicOdxType]:
         key_type = self.switch_key.dop.physical_type.base_data_type
-        lower_limit = key_type.make_from(case.lower_limit)
-        upper_limit = key_type.make_from(case.upper_limit)
+        lower_limit = key_type.make_from(case.lower_limit.value)
+        upper_limit = key_type.make_from(case.upper_limit.value)
         if not isinstance(lower_limit, type(upper_limit)) and not isinstance(
                 upper_limit, type(lower_limit)):
             odxraise("Upper and lower bounds of limits must compareable")
         return lower_limit, upper_limit
 
-    def convert_physical_to_bytes(self,
-                                  physical_value: ParameterValue,
-                                  encode_state: EncodeState,
-                                  bit_position: int = 0) -> bytes:
-
-        if bit_position != 0:
-            raise EncodeError("Multiplexer must be aligned, i.e. bit_position=0, but "
-                              f"{self.short_name} was passed the bit position {bit_position}")
+    @override
+    def encode_into_pdu(self, physical_value: ParameterValue, encode_state: EncodeState) -> None:
+
+        if encode_state.cursor_bit_position != 0:
+            raise EncodeError(f"Multiplexer must be aligned, i.e. bit_position=0, but "
+                              f"{self.short_name} was passed the bit position "
+                              f"{encode_state.cursor_bit_position}")
 
         if not isinstance(physical_value, dict) or len(physical_value) != 1:
             raise EncodeError("""Multiplexer should be defined as a dict
             with only one key equal to the desired case""")
 
+        orig_origin = encode_state.origin_byte_position
+        orig_cursor = encode_state.cursor_byte_position
+
+        encode_state.origin_byte_position = encode_state.cursor_byte_position
+
         case_name, case_value = next(iter(physical_value.items()))
-        case_pos = self.byte_position
 
         for mux_case in self.cases or []:
             if mux_case.short_name == case_name:
-                if mux_case._structure:
-                    case_bytes = mux_case._structure.convert_physical_to_bytes(
-                        case_value, encode_state, 0)
-                else:
-                    case_bytes = b''
-
                 key_value, _ = self._get_case_limits(mux_case)
-                key_bytes = self.switch_key.dop.convert_physical_to_bytes(
-                    key_value, encode_state, bit_position=self.switch_key.bit_position or 0)
-
-                mux_len = max(len(key_bytes), len(case_bytes) + case_pos)
-                mux_bytes = bytearray(mux_len)
-                mux_bytes[:len(key_bytes)] = key_bytes
-                mux_bytes[case_pos:case_pos + len(case_bytes)] = case_bytes
 
-                return bytes(mux_bytes)
+                if self.switch_key.byte_position is not None:
+                    encode_state.cursor_byte_position = encode_state.origin_byte_position + self.switch_key.byte_position
+                encode_state.cursor_bit_position = self.switch_key.bit_position or 0
+
+                self.switch_key.dop.encode_into_pdu(
+                    physical_value=key_value, encode_state=encode_state)
+
+                if self.byte_position is not None:
+                    encode_state.cursor_byte_position = encode_state.origin_byte_position + self.byte_position
+                encode_state.cursor_bit_position = 0
+
+                if mux_case._structure is None:
+                    odxraise(f"Multiplexer case '{mux_case.short_name}' does not "
+                             f"reference a structure.")
+                    return
+
+                mux_case.structure.encode_into_pdu(
+                    physical_value=key_value, encode_state=encode_state)
+
+                encode_state.origin_byte_position = orig_origin
+                encode_state.cursor_byte_position = max(orig_cursor,
+                                                        encode_state.cursor_byte_position)
+                return
 
         raise EncodeError(f"The case {case_name} is not found in Multiplexer {self.short_name}")
 
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
 
         # multiplexers are structures and thus the origin position
         # must be moved to the start of the multiplexer
         orig_origin = decode_state.origin_byte_position
         orig_cursor = decode_state.cursor_byte_position
         if self.byte_position is not None:
@@ -148,34 +164,37 @@
 
         # go back to the original origin
         decode_state.origin_byte_position = orig_origin
         decode_state.cursor_byte_position = max(orig_cursor, decode_state.cursor_byte_position)
 
         return mux_value
 
+    @override
     def _build_odxlinks(self) -> Dict[OdxLinkId, Any]:
         odxlinks = super()._build_odxlinks()
 
         odxlinks.update(self.switch_key._build_odxlinks())
         if self.default_case is not None:
             odxlinks.update(self.default_case._build_odxlinks())
 
         return odxlinks
 
+    @override
     def _resolve_odxlinks(self, odxlinks: OdxLinkDatabase) -> None:
         super()._resolve_odxlinks(odxlinks)
 
         self.switch_key._resolve_odxlinks(odxlinks)
         if self.default_case is not None:
             self.default_case._resolve_odxlinks(odxlinks)
 
         for mux_case in self.cases:
             mux_case._mux_case_resolve_odxlinks(
                 odxlinks, key_physical_type=self.switch_key.dop.physical_type.base_data_type)
 
+    @override
     def _resolve_snrefs(self, diag_layer: "DiagLayer") -> None:
         super()._resolve_snrefs(diag_layer)
 
         self.switch_key._resolve_snrefs(diag_layer)
         if self.default_case is not None:
             self.default_case._resolve_snrefs(diag_layer)
```

## odxtools/multiplexercase.py

```diff
@@ -56,15 +56,15 @@
             **kwargs)
 
     def _build_odxlinks(self) -> Dict[OdxLinkId, Any]:
         return {}
 
     def _resolve_odxlinks(self, odxlinks: OdxLinkDatabase) -> None:
         raise RuntimeError("Calling MultiplexerCase._resolve_odxlinks() is not allowed. "
-                           "Use ._mux_case_resolve_odxlinks()().")
+                           "Use ._mux_case_resolve_odxlinks().")
 
     def _mux_case_resolve_odxlinks(self, odxlinks: OdxLinkDatabase, *,
                                    key_physical_type: DataType) -> None:
         if self.structure_ref:
             self._structure = odxlinks.resolve(self.structure_ref)
 
         self.lower_limit.set_value_type(key_physical_type)
```

## odxtools/nameditemlist.py

```diff
@@ -1,9 +1,10 @@
 # SPDX-License-Identifier: MIT
 import abc
+from copy import deepcopy
 from keyword import iskeyword
 from typing import (Any, Collection, Dict, Iterable, List, Optional, Protocol, SupportsIndex, Tuple,
                     TypeVar, Union, cast, overload, runtime_checkable)
 
 from .exceptions import odxraise
 
 
@@ -171,14 +172,27 @@
 
     def __str__(self) -> str:
         return f"[{', '.join( [self._get_item_key(x) for x in self])}]"
 
     def __repr__(self) -> str:
         return f"{type(self).__name__}([{', '.join([repr(x) for x in self])}])"
 
+    def __copy__(self) -> Any:
+        return self.__class__(list(self))
+
+    def __deepcopy__(self, memo: Dict[int, Any]) -> Any:
+        cls = self.__class__
+        result = cls.__new__(cls)
+        memo[id(self)] = result
+        result._item_dict = {}
+        for x in self:
+            result.append(deepcopy(x, memo))
+
+        return result
+
 
 class NamedItemList(ItemAttributeList[T]):
 
     def _get_item_key(self, item: T) -> str:
         """Transform an object's `short_name` attribute into a valid
         python identifier
```

## odxtools/odxtypes.py

```diff
@@ -150,14 +150,27 @@
         else:
             return 0
 
     odxraise(f"Unhandled comparsion between objects of type {type(a).__name__} "
              f"and {type(b).__name__}")
 
 
+# format specifiers for the data type using the bitstruct module
+_BITSTRUCT_FORMAT_LETTER_MAP__ = {
+    "A_INT32": "s",
+    "A_UINT32": "u",
+    "A_FLOAT32": "f",
+    "A_FLOAT64": "f",
+    "A_BYTEFIELD": "r",
+    "A_UNICODE2STRING": "r",  # UTF-16 strings must be converted explicitly
+    "A_ASCIISTRING": "r",
+    "A_UTF8STRING": "r",
+}
+
+
 class DataType(Enum):
     """Types for the physical and internal value.
 
     These types can be used either as BASE-DATA-TYPE (for the "internal value")
     or the PHYSICAL-DATA-TYPE (for the "physical value").
 
     Relevant pages in the ASAM MCD-2D specification:
@@ -177,14 +190,18 @@
     A_ASCIISTRING = "A_ASCIISTRING"
     A_UTF8STRING = "A_UTF8STRING"
 
     @property
     def python_type(self) -> Type[AtomicOdxType]:
         return _ODX_TYPE_TO_PYTHON_TYPE[self.value]
 
+    @property
+    def bitstruct_format_letter(self) -> str:
+        return _BITSTRUCT_FORMAT_LETTER_MAP__[self.value]
+
     def from_string(self, value: str) -> AtomicOdxType:
         return _PARSE_ODX_TYPE[self.value](value)
 
     @overload
     def create_from_et(self, et_element: None) -> None:
         ...
```

## odxtools/parameterinfo.py

```diff
@@ -1,105 +1,191 @@
 # SPDX-License-Identifier: MIT
-import re
-from typing import Iterable, Union
+import textwrap
+from io import StringIO
+from typing import Iterable
 
 from .compumethods.identicalcompumethod import IdenticalCompuMethod
 from .compumethods.limit import IntervalType
 from .compumethods.linearcompumethod import LinearCompuMethod
 from .compumethods.texttablecompumethod import TexttableCompuMethod
 from .dataobjectproperty import DataObjectProperty
+from .dtcdop import DtcDop
+from .dynamiclengthfield import DynamicLengthField
 from .endofpdufield import EndOfPduField
+from .exceptions import odxrequire
+from .multiplexer import Multiplexer
 from .odxtypes import DataType
 from .parameters.codedconstparameter import CodedConstParameter
 from .parameters.matchingrequestparameter import MatchingRequestParameter
+from .parameters.nrcconstparameter import NrcConstParameter
 from .parameters.parameter import Parameter
 from .parameters.parameterwithdop import ParameterWithDOP
 from .parameters.reservedparameter import ReservedParameter
+from .parameters.tablekeyparameter import TableKeyParameter
+from .parameters.tablestructparameter import TableStructParameter
+from .paramlengthinfotype import ParamLengthInfoType
+from .staticfield import StaticField
 
 
-def parameter_info(param_list: Iterable[Union[Parameter, EndOfPduField]]) -> str:
-    result = ""
+def parameter_info(param_list: Iterable[Parameter], quoted_names: bool = False) -> str:
+    q = "'" if quoted_names else ""
+    of = StringIO()
     for param in param_list:
         if isinstance(param, CodedConstParameter):
-            result += f"{param.short_name} : const = {param._coded_value_str}\n"
+            of.write(f"{q}{param.short_name}{q}: const = {param._coded_value_str}\n")
             continue
         elif isinstance(param, MatchingRequestParameter):
-            result += f"{param.short_name} : <matches request>\n"
+            of.write(f"{q}{param.short_name}{q}: <matches request>\n")
+            continue
+        elif isinstance(param, NrcConstParameter):
+            of.write(f"{q}{param.short_name}{q}: const; choices = {param.coded_values}\n")
             continue
         elif isinstance(param, ReservedParameter):
-            result += f"{param.short_name} : <reserved>\n"
+            of.write(f"{q}{param.short_name}{q}: <reserved>\n")
+            continue
+        elif isinstance(param, TableKeyParameter):
+            of.write(
+                f"{q}{param.short_name}{q}: <optional> table key; table = '{param.table.short_name}'; choices:\n"
+            )
+            for tr in param.table.table_rows:
+                of.write(f"  '{tr.short_name}',\n")
+
+            continue
+        elif isinstance(param, TableStructParameter):
+            of.write(
+                f"{q}{param.short_name}{q}: table struct; key = '{param.table_key.short_name}'; choices:\n"
+            )
+            for tr in param.table_key.table.table_rows:
+                of.write(f"  ('{tr.short_name}',\n")
+                of.write(f"   {{\n")
+                of.write(
+                    textwrap.indent(
+                        parameter_info(odxrequire(tr.structure).parameters, True), "    "))
+                of.write(f"   }}),\n")
+
             continue
         elif not isinstance(param, ParameterWithDOP):
-            result += f"{param.short_name} : <unhandled parameter type>\n"
+            of.write(
+                f"{q}{param.short_name}{q}: <unhandled parameter type '{type(param).__name__}'>\n")
             continue
 
         dop = param.dop
-
         if isinstance(dop, EndOfPduField):
-            result += f"{param.short_name} : <optional> list({{\n"
-            tmp = parameter_info(dop.structure.parameters).strip()
-            tmp = re.sub("^", "  ", tmp)
-            result += tmp + "\n"
-            result += f"}})\n"
+            of.write(f"{q}{param.short_name}{q}: list({{\n")
+            of.write(textwrap.indent(parameter_info(dop.structure.parameters, True), "  "))
+            of.write(f"}})\n")
+            continue
+        elif isinstance(dop, StaticField):
+            of.write(f"{q}{param.short_name}{q}: length={dop.fixed_number_of_items}; list({{\n")
+            of.write(textwrap.indent(parameter_info(dop.structure.parameters, True), "  "))
+            of.write(f"}})\n")
+            continue
+        elif isinstance(dop, DynamicLengthField):
+            of.write(f"{q}{param.short_name}{q}: list({{\n")
+            of.write(textwrap.indent(parameter_info(dop.structure.parameters, True), "  "))
+            of.write(f"}})\n")
+            continue
+        elif isinstance(dop, ParamLengthInfoType):
+            of.write(f"{q}{param.short_name}{q}: ")
+            of.write("<optional> ")
+            of.write(f"int; length_key='{dop.length_key.short_name}'\n")
+            continue
+        elif isinstance(dop, DtcDop):
+            of.write(f"{q}{param.short_name}{q}: ")
+            of.write(f"DTC; choices:\n")
+            for dtc in dop.dtcs:
+                if dtc.display_trouble_code is not None:
+                    dtc_desc = dtc.text and f"; \"{dtc.text}\""
+                    of.write(
+                        f"  '{dtc.display_trouble_code}' (0x{dtc.trouble_code:06x}{dtc_desc})\n")
+                else:
+                    dtc_desc = dtc.text and f" (\"{dtc.text}\")"
+                    of.write(f"  0x{dtc.trouble_code:06x}{dtc_desc}\n")
+            continue
+        elif isinstance(dop, Multiplexer):
+            of.write(f"{q}{param.short_name}{q}: ")
+            if dop.default_case is not None:
+                of.write(f"<optional>")
+            of.write(f"multiplexer; choices:\n")
+            for mux_case in dop.cases:
+                of.write(f"  ({repr(mux_case.short_name)}, {{\n")
+                of.write(
+                    textwrap.indent(parameter_info(mux_case.structure.parameters, True), "    "))
+                of.write(f"   }})\n")
             continue
 
-        result += f"{param.short_name}"
+        of.write(f"{q}{param.short_name}{q}")
 
         if dop is None:
-            result += ": <no DOP>\n"
+            of.write(": <no DOP>\n")
             continue
         elif not isinstance(dop, DataObjectProperty):
-            result += ": <unhandled DOP>\n"
+            of.write(f": <unhandled DOP '{type(dop).__name__}'>\n")
             continue
 
         if (cm := dop.compu_method) is None:
-            result += ": <no compu method>\n"
+            of.write(": <no compu method>\n")
             continue
 
         if isinstance(cm, TexttableCompuMethod):
-            result += f": enum; choices:\n"
+            of.write(f": enum; choices:\n")
             for scale in cm.internal_to_phys:
-                result += f"  '{str(scale.compu_const)}'\n"
+                val_str = ""
+                if scale.lower_limit is not None:
+                    val_str = f"({repr(scale.lower_limit.value)})"
+                of.write(f"  {repr(scale.compu_const)}{val_str}\n")
 
         elif isinstance(cm, IdenticalCompuMethod):
             bdt = dop.physical_type.base_data_type
             if bdt in (DataType.A_UTF8STRING, DataType.A_UNICODE2STRING, DataType.A_ASCIISTRING):
-                result += f": str"
-            elif bdt in (DataType.A_BYTEFIELD,):
-                result += f": bytes"
+                of.write(f": str")
+            elif bdt == DataType.A_BYTEFIELD:
+                of.write(f": bytes")
             elif bdt.name.startswith("A_FLOAT"):
-                result += f": float"
+                of.write(f": float")
             elif bdt.name.startswith("A_UINT"):
-                result += f": uint"
+                of.write(f": uint")
             elif bdt.name.startswith("A_INT"):
-                result += f": int"
+                of.write(f": int")
             else:
-                result += f": <unknown type>"
-
-            if (bl := dop.get_static_bit_length()) is not None:
-                result += f"{bl}"
+                of.write(f": <unknown type {{ bdt.name }}>")
 
-            result += "\n"
+            of.write("\n")
 
         elif isinstance(cm, LinearCompuMethod):
-            result += f": float\n"
+            bdt = dop.physical_type.base_data_type
+            if bdt in (DataType.A_UTF8STRING, DataType.A_UNICODE2STRING, DataType.A_ASCIISTRING):
+                of.write(f": str")
+            elif bdt in (DataType.A_BYTEFIELD,):
+                of.write(f": bytes")
+            elif bdt.name.startswith("A_FLOAT"):
+                of.write(f": float")
+            elif bdt.name.startswith("A_UINT"):
+                of.write(f": uint")
+            elif bdt.name.startswith("A_INT"):
+                of.write(f": int")
+            else:
+                of.write(f": <unknown type>")
+
             ll = cm.physical_lower_limit
             ul = cm.physical_upper_limit
-            if ll is None:
-                ll_str = "(inf"
+            if ll is None or ll.interval_type == IntervalType.INFINITE:
+                ll_str = "(-inf"
             else:
-                ll_delim = '[' if ll.interval_type == IntervalType.CLOSED else '('
+                ll_delim = '(' if ll.interval_type == IntervalType.OPEN else '['
                 ll_str = f"{ll_delim}{ll._value!r}"
 
-            if ul is None:
+            if ul is None or ul.interval_type == IntervalType.INFINITE:
                 ul_str = "inf)"
             else:
-                ul_delim = ']' if ul.interval_type == IntervalType.CLOSED else ')'
+                ul_delim = ')' if ul.interval_type == IntervalType.OPEN else ']'
                 ul_str = f"{ul._value!r}{ul_delim}"
-            result += f" range: {ll_str}, {ul_str}\n"
+            of.write(f"; range: {ll_str}, {ul_str}")
 
             unit = dop.unit
             unit_str = unit.display_name if unit is not None else None
             if unit_str is not None:
-                result += f" unit: {unit_str}\n"
+                of.write(f"; unit: {unit_str}")
+
+            of.write("\n")
 
-    return result
+    return of.getvalue()
```

## odxtools/paramlengthinfotype.py

```diff
@@ -1,15 +1,17 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, cast
 
+from typing_extensions import override
+
 from .decodestate import DecodeState
 from .diagcodedtype import DctType, DiagCodedType
 from .encodestate import EncodeState
-from .exceptions import odxraise
+from .exceptions import EncodeError, odxraise
 from .odxlink import OdxLinkDatabase, OdxLinkId, OdxLinkRef
 from .odxtypes import AtomicOdxType, DataType
 
 if TYPE_CHECKING:
     from .diaglayer import DiagLayer
     from .parameters.lengthkeyparameter import LengthKeyParameter
 
@@ -39,62 +41,68 @@
         """Recursively resolve any short-name references"""
         super()._resolve_snrefs(diag_layer)
 
     @property
     def length_key(self) -> "LengthKeyParameter":
         return self._length_key
 
-    def convert_internal_to_bytes(self, internal_value: AtomicOdxType, encode_state: EncodeState,
-                                  bit_position: int) -> bytes:
-        bit_length = encode_state.parameter_values.get(self.length_key.short_name, None)
+    @override
+    def encode_into_pdu(self, internal_value: AtomicOdxType, encode_state: EncodeState) -> None:
+        bit_length = encode_state.length_keys.get(self.length_key.short_name)
 
         if bit_length is None:
+            # the length key is implicit, i.e., we need to set the
+            # value for the length key in the encode_state based on
+            # the value passed here.
             if self.base_data_type in [
                     DataType.A_BYTEFIELD,
                     DataType.A_ASCIISTRING,
                     DataType.A_UTF8STRING,
             ]:
-                bit_length = 8 * len(internal_value)  # type: ignore[arg-type]
-            if self.base_data_type in [DataType.A_UNICODE2STRING]:
-                bit_length = 16 * len(internal_value)  # type: ignore[arg-type]
-
-            if self.base_data_type in [DataType.A_INT32, DataType.A_UINT32]:
+                bit_length = 8 * len(cast(str, internal_value))
+            elif self.base_data_type in [DataType.A_UNICODE2STRING]:
+                bit_length = 16 * len(cast(str, internal_value))
+            elif self.base_data_type in [DataType.A_INT32, DataType.A_UINT32]:
                 bit_length = int(internal_value).bit_length()
                 if self.base_data_type == DataType.A_INT32:
                     bit_length += 1
                 # Round up
                 bit_length = ((bit_length + 7) // 8) * 8
-
-            encode_state.parameter_values[self.length_key.short_name] = bit_length
-
-        if bit_length is None:
-            odxraise()
-
-        return self._encode_internal_value(
-            internal_value,
-            bit_position=bit_position,
+            elif self.base_data_type == DataType.A_FLOAT32:
+                bit_length = 32
+            elif self.base_data_type == DataType.A_FLOAT64:
+                bit_length = 64
+            else:
+                odxraise(
+                    f"Cannot determine size of an object of type "
+                    f"{self.base_data_type.value}", EncodeError)
+                return
+
+            encode_state.length_keys[self.length_key.short_name] = bit_length
+
+        encode_state.emplace_atomic_value(
+            internal_value=internal_value,
+            used_mask=None,
             bit_length=bit_length,
             base_data_type=self.base_data_type,
             is_highlow_byte_order=self.is_highlow_byte_order,
         )
 
     def decode_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
         # First, we need to find a length key with matching ID.
         if self.length_key.short_name not in decode_state.length_keys:
             odxraise(f"Unspecified mandatory length key parameter "
                      f"{self.length_key.short_name}")
-            decode_state.cursor_bit_position = None
+            decode_state.cursor_bit_position = 0
             return cast(None, AtomicOdxType)
 
         bit_length = decode_state.length_keys[self.length_key.short_name]
         if not isinstance(bit_length, int):
             odxraise(f"The bit length must be an integer, is {type(bit_length)}")
             bit_length = 0
 
         # Extract the internal value and return.
-        value = decode_state.extract_atomic_value(
+        return decode_state.extract_atomic_value(
             bit_length,
             self.base_data_type,
             self.is_highlow_byte_order,
         )
-
-        return value
```

## odxtools/request.py

```diff
@@ -1,14 +1,16 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import List
 from xml.etree import ElementTree
 
 from .basicstructure import BasicStructure
+from .encodestate import EncodeState
 from .odxlink import OdxDocFragment
+from .odxtypes import ParameterValue
 from .utils import dataclass_fields_asdict
 
 
 # TODO: The spec does not say that requests are basic structures. For
 # now, we derive from it anyway because it simplifies the en- and
 # decoding machinery...
 @dataclass
@@ -16,7 +18,14 @@
 
     @staticmethod
     def from_et(et_element: ElementTree.Element, doc_frags: List[OdxDocFragment]) -> "Request":
         """Reads a response."""
         kwargs = dataclass_fields_asdict(BasicStructure.from_et(et_element, doc_frags))
 
         return Request(**kwargs)
+
+    def encode(self, **kwargs: ParameterValue) -> bytes:
+        encode_state = EncodeState(is_end_of_pdu=True)
+
+        self.encode_into_pdu(physical_value=kwargs, encode_state=encode_state)
+
+        return encode_state.coded_message
```

## odxtools/response.py

```diff
@@ -1,18 +1,18 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from enum import Enum
 from typing import List, Optional, cast
 from xml.etree import ElementTree
 
 from .basicstructure import BasicStructure
+from .encodestate import EncodeState
 from .exceptions import odxraise
 from .odxlink import OdxDocFragment
 from .odxtypes import ParameterValue
-from .parameters.matchingrequestparameter import MatchingRequestParameter
 from .utils import dataclass_fields_asdict
 
 
 class ResponseType(Enum):
     POSITIVE = "POS-RESPONSE"
     NEGATIVE = "NEG-RESPONSE"
     GLOBAL_NEGATIVE = "GLOBAL-NEG-RESPONSE"
@@ -34,21 +34,13 @@
             response_type = ResponseType(et_element.tag)
         except ValueError:
             response_type = cast(ResponseType, None)
             odxraise(f"Encountered unknown response type '{et_element.tag}'")
 
         return Response(response_type=response_type, **kwargs)
 
-    def encode(self, coded_request: Optional[bytes] = None, **params: ParameterValue) -> bytes:
-        if coded_request is not None:
-            # Extract MATCHING-REQUEST-PARAMs from the coded
-            # request. TODO: this should be done by
-            # MatchingRequestParam itself!
-            for param in self.parameters:
-                if isinstance(param, MatchingRequestParameter):
-                    byte_pos = param.request_byte_position
-                    byte_length = param.byte_length
+    def encode(self, coded_request: Optional[bytes] = None, **kwargs: ParameterValue) -> bytes:
+        encode_state = EncodeState(triggering_request=coded_request, is_end_of_pdu=True)
 
-                    val = coded_request[byte_pos:byte_pos + byte_length]
-                    params[param.short_name] = val
+        self.encode_into_pdu(physical_value=kwargs, encode_state=encode_state)
 
-        return super().encode(coded_request=coded_request, **params)
+        return encode_state.coded_message
```

## odxtools/standardlengthtype.py

```diff
@@ -1,65 +1,103 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import Optional
+from typing import Literal, Optional
+
+from typing_extensions import override
 
 from .decodestate import DecodeState
 from .diagcodedtype import DctType, DiagCodedType
 from .encodestate import EncodeState
-from .exceptions import odxassert, odxraise
+from .exceptions import odxassert, odxraise, odxrequire
 from .odxtypes import AtomicOdxType, DataType
 
 
 @dataclass
 class StandardLengthType(DiagCodedType):
 
     bit_length: int
     bit_mask: Optional[int]
     is_condensed_raw: Optional[bool]
 
     @property
     def dct_type(self) -> DctType:
         return "STANDARD-LENGTH-TYPE"
 
+    @property
+    def is_condensed(self) -> bool:
+        return self.is_condensed_raw is True
+
     def __post_init__(self) -> None:
         if self.bit_mask is not None:
             maskable_types = (DataType.A_UINT32, DataType.A_INT32, DataType.A_BYTEFIELD)
             odxassert(
                 self.base_data_type in maskable_types,
                 'Can not apply a bit_mask on a value of type {self.base_data_type}',
             )
 
+    def __get_raw_mask(self, internal_value: AtomicOdxType) -> Optional[bytes]:
+        """Returns a byte field where all bits that are used by the
+        DiagCoded type are set and all unused ones are not set.
+
+        If `None` is returned, all bits are used.
+        """
+        if self.bit_mask is None:
+            return None
+
+        if self.is_condensed:
+            odxraise("Condensed bit masks are not yet supported", NotImplementedError)
+            return
+
+        endianness: Literal["little", "big"] = "big"
+        if not self.is_highlow_byte_order and self.base_data_type in [
+                DataType.A_INT32, DataType.A_UINT32, DataType.A_FLOAT32, DataType.A_FLOAT64
+        ]:
+            # TODO (?): Technically, little endian A_UNICODE2STRING
+            # objects require a byte swap for each 16 bit letter, and
+            # thus also for the mask. I somehow doubt that this has
+            # been anticipated by the standard, though...
+            endianness = "little"
+
+        sz: int
+        if isinstance(internal_value, (bytes, bytearray)):
+            sz = len(internal_value)
+        else:
+            sz = (odxrequire(self.get_static_bit_length()) + 7) // 8
+
+        return self.bit_mask.to_bytes(sz, endianness)
+
     def __apply_mask(self, internal_value: AtomicOdxType) -> AtomicOdxType:
         if self.bit_mask is None:
             return internal_value
-        if self.is_condensed_raw is True:
-            raise NotImplementedError("Serialization of condensed bit mask is not supported")
+        if self.is_condensed:
+            odxraise("Serialization of condensed bit mask is not supported", NotImplementedError)
+            return
         if isinstance(internal_value, int):
             return internal_value & self.bit_mask
         if isinstance(internal_value, bytes):
             int_value = int.from_bytes(internal_value, 'big')
             int_value = int_value & self.bit_mask
             return int_value.to_bytes(len(internal_value), 'big')
 
         odxraise(f'Can not apply a bit_mask on a value of type {type(internal_value)}')
         return internal_value
 
     def get_static_bit_length(self) -> Optional[int]:
         return self.bit_length
 
-    def convert_internal_to_bytes(self, internal_value: AtomicOdxType, encode_state: EncodeState,
-                                  bit_position: int) -> bytes:
-        return self._encode_internal_value(
-            self.__apply_mask(internal_value),
-            bit_position,
-            self.bit_length,
-            self.base_data_type,
-            is_highlow_byte_order=self.is_highlow_byte_order,
-        )
+    @override
+    def encode_into_pdu(self, internal_value: AtomicOdxType, encode_state: EncodeState) -> None:
+        encode_state.emplace_atomic_value(
+            internal_value=self.__apply_mask(internal_value),
+            used_mask=self.__get_raw_mask(internal_value),
+            bit_length=self.bit_length,
+            base_data_type=self.base_data_type,
+            is_highlow_byte_order=self.is_highlow_byte_order)
 
+    @override
     def decode_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
         internal_value = decode_state.extract_atomic_value(
             self.bit_length,
             self.base_data_type,
             self.is_highlow_byte_order,
         )
         internal_value = self.__apply_mask(internal_value)
```

## odxtools/staticfield.py

```diff
@@ -44,44 +44,40 @@
         super()._resolve_odxlinks(odxlinks)
 
     @override
     def _resolve_snrefs(self, diag_layer: "DiagLayer") -> None:
         super()._resolve_snrefs(diag_layer)
 
     @override
-    def convert_physical_to_bytes(
-        self,
-        physical_value: ParameterValue,
-        encode_state: EncodeState,
-        bit_position: int = 0,
-    ) -> bytes:
+    def encode_into_pdu(self, physical_value: ParameterValue, encode_state: EncodeState) -> None:
+
         if not isinstance(physical_value,
                           (tuple, list)) or len(physical_value) != self.fixed_number_of_items:
             odxraise(f"Value for static field '{self.short_name}' "
                      f"must be a list of size {self.fixed_number_of_items}")
 
-        result = bytearray()
         for val in physical_value:
             if not isinstance(val, dict):
                 odxraise(f"The individual parameter values for static field '{self.short_name}' "
                          f"must be dictionaries for structure '{self.structure.short_name}'")
 
-            data = self.structure.convert_physical_to_bytes(val, encode_state)
-
-            if len(data) > self.item_byte_size:
-                odxraise(f"Insufficient item byte size for static field {self.short_name}: "
-                         f"Is {self.item_byte_size} bytes, but need at least {len(data)} bytes")
-                data = data[:self.item_byte_size]
-            elif len(data) < self.item_byte_size:
+            pos_before = encode_state.cursor_byte_position
+            self.structure.encode_into_pdu(val, encode_state)
+            pos_after = encode_state.cursor_byte_position
+
+            if pos_after - pos_before > self.item_byte_size:
+                odxraise(
+                    f"Insufficient item byte size for static field {self.short_name}: "
+                    f"Is {self.item_byte_size} bytes, but need at least {pos_after - pos_before} bytes"
+                )
+                encode_state.cursor_byte_position = pos_before + self.item_byte_size
+            elif pos_after - pos_before < self.item_byte_size:
                 # add some padding bytes
-                data = data.ljust(self.item_byte_size, b'\x00')
-
-            result += data
-
-        return result
+                encode_state.emplace_bytes(b'\x00' * (self.item_byte_size -
+                                                      (pos_after - pos_before)))
 
     @override
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
 
         odxassert(decode_state.cursor_bit_position == 0,
                   "No bit position can be specified for static length fields!")
```

## odxtools/version.py

```diff
@@ -8,9 +8,9 @@
     VERSION_TUPLE = object
 
 version: str
 __version__: str
 __version_tuple__: VERSION_TUPLE
 version_tuple: VERSION_TUPLE
 
-__version__ = version = '6.7.1'
-__version_tuple__ = version_tuple = (6, 7, 1)
+__version__ = version = '7.0.0'
+__version_tuple__ = version_tuple = (7, 0, 0)
```

## odxtools/parameters/codedconstparameter.py

```diff
@@ -6,17 +6,17 @@
 
 from typing_extensions import override
 
 from ..createanydiagcodedtype import create_any_diag_coded_type_from_et
 from ..decodestate import DecodeState
 from ..diagcodedtype import DiagCodedType
 from ..encodestate import EncodeState
-from ..exceptions import DecodeError, odxrequire
+from ..exceptions import DecodeError, EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
-from ..odxtypes import AtomicOdxType, DataType
+from ..odxtypes import AtomicOdxType, DataType, ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import Parameter, ParameterType
 
 if TYPE_CHECKING:
     from ..diaglayer import DiagLayer
 
 
@@ -77,28 +77,31 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return False
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        if (self.short_name in encode_state.parameter_values and
-                encode_state.parameter_values[self.short_name] != self.coded_value):
-            raise TypeError(f"The parameter '{self.short_name}' is constant {self._coded_value_str}"
-                            " and thus can not be changed.")
-        bit_position_int = self.bit_position if self.bit_position is not None else 0
-        return self.diag_coded_type.convert_internal_to_bytes(
-            self.coded_value, encode_state=encode_state, bit_position=bit_position_int)
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        if physical_value is not None and physical_value != self.coded_value:
+            odxraise(
+                f"Value for constant parameter `{self.short_name}` name can "
+                f"only be specified as {self.coded_value!r} (is: {physical_value!r})", EncodeError)
+
+        internal_value = self.coded_value
+
+        self.diag_coded_type.encode_into_pdu(
+            internal_value=internal_value, encode_state=encode_state)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
         coded_val = self.diag_coded_type.decode_from_pdu(decode_state)
 
-        # Check if the coded value in the message is correct.
+        # Check if the coded value contained by the message is correct.
         if self.coded_value != coded_val:
             warnings.warn(
                 f"Coded constant parameter does not match! "
                 f"The parameter {self.short_name} expected coded "
                 f"value {str(self._coded_value_str)} but got {str(coded_val)} "
                 f"at byte position {decode_state.cursor_byte_position} "
                 f"in coded message {decode_state.coded_message.hex()}.",
```

## odxtools/parameters/dynamicparameter.py

```diff
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import List
+from typing import List, Optional
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
 from ..odxlink import OdxDocFragment
@@ -37,13 +37,14 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         raise NotImplementedError(".is_settable for a DynamicParameter")
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        raise NotImplementedError("Encoding a DynamicParameter is not implemented yet.")
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        raise NotImplementedError("Encoding DynamicParameter is not implemented yet.")
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
-        raise NotImplementedError("Decoding a DynamicParameter is not implemented yet.")
+        raise NotImplementedError("Decoding DynamicParameter is not implemented yet.")
```

## odxtools/parameters/lengthkeyparameter.py

```diff
@@ -1,17 +1,17 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, Any, Dict, List
+from typing import TYPE_CHECKING, Any, Dict, List, Optional
 from xml.etree import ElementTree
 
-from typing_extensions import override
+from typing_extensions import final, override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
-from ..exceptions import odxraise, odxrequire
+from ..exceptions import EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
 from ..odxtypes import ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import ParameterType
 from .parameterwithdop import ParameterWithDOP
 
 if TYPE_CHECKING:
@@ -73,25 +73,73 @@
     def is_settable(self) -> bool:
         # length keys can be explicitly set, but they do not need to
         # be because they can be implicitly determined by the length
         # of the corresponding field
         return True
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        physical_value = encode_state.parameter_values.get(self.short_name, 0)
+    @final
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        # if you get this exception, you ought to use
+        # `.encode_placeholder_into_pdu()` followed by (after the
+        # value of the length key has been determined)
+        # `.encode_value_into_pdu()`.
+        raise RuntimeError("_encode_positioned_into_pdu() cannot be called for length keys.")
+
+    def encode_placeholder_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+
+        if physical_value is not None:
+            if not self.dop.is_valid_physical_value(physical_value):
+                odxraise(f"Invalid explicitly specified physical value '{physical_value!r}' "
+                         f"for length key '{self.short_name}'.")
+
+            lkv = encode_state.length_keys.get(self.short_name)
+            if lkv is not None and lkv != physical_value:
+                odxraise(f"Got conflicting values for length key {self.short_name}: "
+                         f"{lkv} and {physical_value!r}")
+
+            if not isinstance(physical_value, int):
+                odxraise(
+                    f"Value of length key {self.short_name} is of type {type(physical_value).__name__} "
+                    f"instead of int")
+
+            encode_state.length_keys[self.short_name] = physical_value
+
+        orig_cursor = encode_state.cursor_byte_position
+        pos = encode_state.cursor_byte_position
+        if self.byte_position is not None:
+            pos = encode_state.origin_byte_position + self.byte_position
+        encode_state.key_pos[self.short_name] = pos
+        encode_state.cursor_byte_position = pos
+        encode_state.cursor_bit_position = self.bit_position or 0
+
+        # emplace a value of zero into the encode state, but pretend the bits not to be used
+        n = odxrequire(self.dop.get_static_bit_length()) + encode_state.cursor_bit_position
+        tmp_val = b'\x00' * ((n + 7) // 8)
+        encode_state.emplace_bytes(tmp_val, obj_used_mask=tmp_val)
+
+        encode_state.cursor_byte_position = max(encode_state.cursor_byte_position, orig_cursor)
+        encode_state.cursor_bit_position = 0
+
+    def encode_value_into_pdu(self, encode_state: EncodeState) -> None:
+
+        if self.short_name not in encode_state.length_keys:
+            odxraise(
+                f"Length key {self.short_name} has not been defined before "
+                f"it is required.", EncodeError)
+            return
+        else:
+            physical_value = encode_state.length_keys[self.short_name]
 
-        bit_pos = self.bit_position or 0
-        dop = odxrequire(super().dop,
-                         f"A DOP is required for length key parameter {self.short_name}")
-        return dop.convert_physical_to_bytes(physical_value, encode_state, bit_position=bit_pos)
+        encode_state.cursor_byte_position = encode_state.key_pos[self.short_name]
+        encode_state.cursor_bit_position = self.bit_position or 0
 
-    @override
-    def encode_into_pdu(self, encode_state: EncodeState) -> bytes:
-        return super().encode_into_pdu(encode_state)
+        self.dop.encode_into_pdu(encode_state=encode_state, physical_value=physical_value)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         phys_val = super()._decode_positioned_from_pdu(decode_state)
 
         if not isinstance(phys_val, int):
             odxraise(f"The pysical type of length keys must be an integer, "
```

## odxtools/parameters/matchingrequestparameter.py

```diff
@@ -3,15 +3,15 @@
 from typing import List, Optional
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
-from ..exceptions import EncodeError, odxrequire
+from ..exceptions import EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment
 from ..odxtypes import DataType, ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import Parameter, ParameterType
 
 
 @dataclass
@@ -48,23 +48,35 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return False
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        if not encode_state.triggering_request:
-            raise EncodeError(f"Parameter '{self.short_name}' is of matching request type,"
-                              " but no original request has been specified.")
-        return encode_state.triggering_request[self
-                                               .request_byte_position:self.request_byte_position +
-                                               self.byte_length]
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        if encode_state.triggering_request is None:
+            odxraise(
+                f"Parameter '{self.short_name}' is of matching request type,"
+                f" but no original request has been specified.", EncodeError)
+            return
+
+        rq_pos = self.request_byte_position
+        rq_len = self.byte_length
+
+        if len(encode_state.triggering_request) < rq_pos + rq_len:
+            odxraise(
+                f"Specified triggering request 0x{encode_state.triggering_request.hex()} "
+                f"is not long enough to encode matching request parameter "
+                f"'{self.short_name}': Have {len(encode_state.triggering_request)} "
+                f"bytes, need at least {rq_pos + rq_len} bytes", EncodeError)
+            return
+
+        encode_state.emplace_bytes(encode_state.triggering_request[rq_pos:rq_pos + rq_len],
+                                   self.short_name)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
-        result = decode_state.extract_atomic_value(
+        return decode_state.extract_atomic_value(
             bit_length=self.byte_length * 8,
             base_data_type=DataType.A_UINT32,
             is_highlow_byte_order=False)
-
-        return result
```

## odxtools/parameters/nrcconstparameter.py

```diff
@@ -1,38 +1,44 @@
 # SPDX-License-Identifier: MIT
 import warnings
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, Any, Dict, List, Optional
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, cast
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..createanydiagcodedtype import create_any_diag_coded_type_from_et
 from ..decodestate import DecodeState
 from ..diagcodedtype import DiagCodedType
 from ..encodestate import EncodeState
-from ..exceptions import DecodeError, EncodeError, odxrequire
+from ..exceptions import DecodeError, EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
-from ..odxtypes import AtomicOdxType, DataType
+from ..odxtypes import AtomicOdxType, DataType, ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import Parameter, ParameterType
 
 if TYPE_CHECKING:
     from ..diaglayer import DiagLayer
 
 
 @dataclass
 class NrcConstParameter(Parameter):
-    """A param of type NRC-CONST defines a set of values to be matched.
+    """A param of type NRC-CONST defines a set of values to be matched for a negative response to apply.
 
-    An NRC-CONST can only be used in a negative response.
-    Its encoding behaviour is similar to a VALUE parameter with a TEXTTABLE.
-    However, an NRC-CONST is used for matching a response (similar to a CODED-CONST).
+    The behaviour of NRC-CONST parameters is similar to CODED-CONST
+    parameters in that they allow to specify which coding objects
+    apply to a binary string, but in contrast to CODED-CONST
+    parameters they allow to specify multiple values. Thus, the value
+    of a CODED-CONST parameter is usually set using an overlapping
+    VALUE parameter. Since NRC-CONST parameters can only be specified
+    for negative responses, they can thus be regarded as a multiplexer
+    mechanism that is specific to negative responses.
 
     See ASAM MCD-2 D (ODX), p. 77-79.
+
     """
 
     diag_coded_type: DiagCodedType
     coded_values: List[AtomicOdxType]
 
     @staticmethod
     @override
@@ -87,29 +93,42 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return False
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        if self.short_name in encode_state.parameter_values:
-            if encode_state.parameter_values[self.short_name] not in self.coded_values:
-                raise EncodeError(f"The parameter '{self.short_name}' must have"
-                                  f" one of the constant values {self.coded_values}")
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        coded_value: ParameterValue
+        if physical_value is not None:
+            if physical_value not in self.coded_values:
+                odxraise(
+                    f"The value of parameter '{self.short_name}' must "
+                    f" be one of {self.coded_values} (is: {physical_value!r})", EncodeError)
+                coded_value = self.coded_values[0]
             else:
-                coded_value = encode_state.parameter_values[self.short_name]
+                coded_value = physical_value
         else:
-            # If the user does not select one, just select any.
-            # I think it does not matter ...
-            coded_value = self.coded_values[0]
-
-        bit_position_int = self.bit_position if self.bit_position is not None else 0
-        return self.diag_coded_type.convert_internal_to_bytes(
-            coded_value, encode_state, bit_position=bit_position_int)
+            # If the user did not select a value, the value of the
+            # this parameter is set by another parameter which
+            # overlaps with it. We thus just move the cursor.
+            bit_pos = encode_state.cursor_bit_position
+            bit_len = self.diag_coded_type.get_static_bit_length()
+
+            if bit_len is None:
+                odxraise("The diag coded type of NRC-CONST parameters must "
+                         "exhibit a static size")
+                return
+
+            encode_state.cursor_byte_position += (bit_pos + bit_len + 7) // 8
+            encode_state.cursor_bit_position = 0
+            return
+
+        self.diag_coded_type.encode_into_pdu(cast(AtomicOdxType, coded_value), encode_state)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> AtomicOdxType:
         # Extract coded values
         coded_value = self.diag_coded_type.decode_from_pdu(decode_state)
 
         # Check if the coded value in the message is correct.
```

## odxtools/parameters/parameter.py

```diff
@@ -113,20 +113,43 @@
 
         Required parameters are always settable, and parameters which
         have a default value are settable but not required to be
         specified.
         """
         raise NotImplementedError(".is_settable is not implemented by the concrete parameter class")
 
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        """Get the coded value of the parameter given the encode state.
-        Note that this method is called by `encode_into_pdu`.
+    @final
+    def encode_into_pdu(self, physical_value: Optional[ParameterValue],
+                        encode_state: EncodeState) -> None:
+        """Convert a physical value into its encoded form and place it into the PDU
+
+        Also, adapt the `encode_state` so that it points to where the next
+        parameter is located (if the parameter does not explicitly specify a
+        position)
         """
+
+        orig_cursor = encode_state.cursor_byte_position
+        if self.byte_position is not None:
+            encode_state.cursor_byte_position = encode_state.origin_byte_position + self.byte_position
+
+        encode_state.cursor_bit_position = self.bit_position or 0
+
+        self._encode_positioned_into_pdu(physical_value, encode_state)
+
+        encode_state.cursor_byte_position = max(encode_state.cursor_byte_position, orig_cursor)
+        encode_state.cursor_bit_position = 0
+
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        """Method which actually encodes the parameter
+
+        Its location is managed by `Parameter`."""
         raise NotImplementedError(
-            ".get_coded_value_as_bytes() is not implemented by the concrete parameter class")
+            f"Required method '_encode_positioned_into_pdu()' not implemented by "
+            f"child class {type(self).__name__}")
 
     @final
     def decode_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         orig_cursor = decode_state.cursor_byte_position
         if self.byte_position is not None:
             decode_state.cursor_byte_position = decode_state.origin_byte_position + self.byte_position
 
@@ -140,45 +163,9 @@
         return result
 
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         """Method which actually decodes the parameter
 
         Its location is managed by `Parameter`."""
         raise NotImplementedError(
-            "Required method '_decode_positioned_from_pdu()' not implemented by child class")
-
-    def encode_into_pdu(self, encode_state: EncodeState) -> bytes:
-        """Encode the value of a parameter into a binary blob and return it
-
-        If the byte position of the parameter is not defined,
-        the byte code is appended to the blob.
-
-        Technical note for subclasses: The default implementation
-        tries to compute the coded value via
-        `self.get_coded_value_as_bytes(encoded_state)` and inserts it
-        into the PDU. Thus it usually suffices to overwrite
-        `get_coded_value_as_bytes()` instead of `encode_into_pdu()`.
-
-        Parameters:
-        ----------
-        encode_state: EncodeState, i.e. a named tuple with attributes
-            * coded_message: bytes, the message encoded so far
-            * parameter_values: List[ParameterValuePairs]
-            * triggering_coded_request: bytes
-
-        Returns:
-        -------
-        bytes
-            the message's blob after adding the encoded parameter into it
-
-        """
-        msg_blob = encode_state.coded_message
-        param_blob = self.get_coded_value_as_bytes(encode_state)
-
-        if self.byte_position is not None:
-            byte_position = self.byte_position
-        else:
-            byte_position = len(msg_blob)
-
-        encode_state.emplace_atomic_value(param_blob, self.short_name, byte_position)
-
-        return encode_state.coded_message
+            f"Required method '_decode_positioned_from_pdu()' not implemented by "
+            f"child class {type(self).__name__}")
```

## odxtools/parameters/parameterwithdop.py

```diff
@@ -1,22 +1,22 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, Any, Dict, List, Optional
+from typing import TYPE_CHECKING, Any, Dict, List, Optional, cast
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..dataobjectproperty import DataObjectProperty
 from ..decodestate import DecodeState
 from ..dopbase import DopBase
 from ..dtcdop import DtcDop
 from ..encodestate import EncodeState
 from ..exceptions import odxassert, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId, OdxLinkRef
-from ..odxtypes import ParameterValue
+from ..odxtypes import AtomicOdxType, ParameterValue
 from ..physicaltype import PhysicalType
 from ..utils import dataclass_fields_asdict
 from .parameter import Parameter
 
 if TYPE_CHECKING:
     from ..diaglayer import DiagLayer
 
@@ -87,17 +87,14 @@
     def physical_type(self) -> Optional[PhysicalType]:
         if isinstance(self.dop, (DataObjectProperty, DtcDop)):
             return self.dop.physical_type
         else:
             return None
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        dop = odxrequire(self.dop, "Reference to DOP is not resolved")
-        physical_value = encode_state.parameter_values[self.short_name]
-        bit_position_int = self.bit_position if self.bit_position is not None else 0
-        return dop.convert_physical_to_bytes(
-            physical_value, encode_state, bit_position=bit_position_int)
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        self.dop.encode_into_pdu(cast(AtomicOdxType, physical_value), encode_state)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         return self.dop.decode_from_pdu(decode_state)
```

## odxtools/parameters/physicalconstantparameter.py

```diff
@@ -1,18 +1,18 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, Any, Dict, List
+from typing import TYPE_CHECKING, Any, Dict, List, Optional
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..dataobjectproperty import DataObjectProperty
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
-from ..exceptions import DecodeError, odxraise, odxrequire
+from ..exceptions import DecodeError, EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
 from ..odxtypes import ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import ParameterType
 from .parameterwithdop import ParameterWithDOP
 
 if TYPE_CHECKING:
@@ -70,33 +70,32 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return False
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        dop = odxrequire(self.dop, "Reference to DOP is not resolved")
-        if (self.short_name in encode_state.parameter_values and
-                encode_state.parameter_values[self.short_name] != self.physical_constant_value):
-            raise TypeError(
-                f"The parameter '{self.short_name}' is constant {self.physical_constant_value!r}"
-                f" and thus can not be changed.")
-
-        bit_position_int = self.bit_position if self.bit_position is not None else 0
-        return dop.convert_physical_to_bytes(
-            self.physical_constant_value, encode_state, bit_position=bit_position_int)
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        if physical_value is not None and physical_value != self.physical_constant_value:
+            odxraise(
+                f"Value for constant parameter `{self.short_name}` name can "
+                f"only be specified as {self.physical_constant_value!r} (is: {physical_value!r})",
+                EncodeError)
+
+        self.dop.encode_into_pdu(self.physical_constant_value, encode_state)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         # Decode value
         phys_val = super()._decode_positioned_from_pdu(decode_state)
 
         # Check if decoded value matches expected value
         if phys_val != self.physical_constant_value:
             odxraise(
                 f"Physical constant parameter does not match! "
                 f"The parameter {self.short_name} expected physical value "
                 f"{self.physical_constant_value!r} but got {phys_val!r} "
                 f"at byte position {decode_state.cursor_byte_position} "
                 f"in coded message {decode_state.coded_message.hex()}.", DecodeError)
+
         return phys_val
```

## odxtools/parameters/reservedparameter.py

```diff
@@ -45,16 +45,19 @@
         return False
 
     @override
     def get_static_bit_length(self) -> Optional[int]:
         return self.bit_length
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        return (0).to_bytes(((self.bit_position or 0) + self.bit_length + 7) // 8, "big")
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        raw_data = (0).to_bytes((encode_state.cursor_bit_position + self.bit_length + 7) // 8,
+                                "big")
+        encode_state.emplace_bytes(raw_data, self.short_name)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         return decode_state.extract_atomic_value(
             bit_length=self.bit_length,
             base_data_type=DataType.A_UINT32,
             is_highlow_byte_order=False)
```

## odxtools/parameters/systemparameter.py

```diff
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import List
+from typing import List, Optional
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
 from ..exceptions import odxrequire
@@ -42,13 +42,14 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         raise NotImplementedError("SystemParameter.is_settable is not implemented yet.")
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
         raise NotImplementedError("Encoding a SystemParameter is not implemented yet.")
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         raise NotImplementedError("Decoding SystemParameter is not implemented yet.")
```

## odxtools/parameters/tableentryparameter.py

```diff
@@ -1,10 +1,10 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
-from typing import TYPE_CHECKING, List
+from typing import TYPE_CHECKING, List, Optional
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
 from ..exceptions import odxrequire
@@ -55,15 +55,16 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         raise NotImplementedError("TableEntryParameter.is_settable is not implemented yet.")
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
         raise NotImplementedError("Encoding a TableEntryParameter is not implemented yet.")
 
     @property
     def table_row(self) -> "TableRow":
         return self._table_row
 
     @override
```

## odxtools/parameters/tablekeyparameter.py

```diff
@@ -1,13 +1,13 @@
 # SPDX-License-Identifier: MIT
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, List, Optional
 from xml.etree import ElementTree
 
-from typing_extensions import override
+from typing_extensions import final, override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
 from ..exceptions import DecodeError, EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId, OdxLinkRef
 from ..odxtypes import ParameterValue
 from ..utils import dataclass_fields_asdict
@@ -129,54 +129,103 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return True
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        tr_short_name = encode_state.parameter_values.get(self.short_name)
+    @final
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+        # if you get this exception, you ought to use
+        # `.encode_placeholder_into_pdu()` followed by (after the
+        # value of the table key has been determined)
+        # `.encode_value_into_pdu()`.
+        raise RuntimeError("_encode_positioned_into_pdu() cannot be called for table keys.")
 
-        if tr_short_name is None:
-            # the table key has not been defined explicitly yet, but
-            # it is most likely implicitly defined by the associated
-            # TABLE-STRUCT parameters. Use all-zeros as a standin for
-            # the real data...
+    def encode_placeholder_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+
+        if physical_value is not None:
             key_dop = self.table.key_dop
             if key_dop is None:
-                raise EncodeError(f"Table '{self.table.short_name}' does not define "
-                                  f"a KEY-DOP, but is used in TABLE-KEY parameter "
-                                  f"'{self.short_name}'")
-
-            byte_len = (odxrequire(key_dop.get_static_bit_length()) + 7) // 8
-            if self.bit_position is not None and self.bit_position > 0:
-                byte_len += 1
+                odxraise(
+                    f"Table '{self.table.short_name}' does not define "
+                    f"a KEY-DOP, but is used by TABLE-KEY parameter "
+                    f"'{self.short_name}'", EncodeError)
+                return
+
+            if not isinstance(physical_value, str):
+                odxraise(f"Invalid type for for table key '{self.short_name}' specified. "
+                         f"(expect name of table row.)")
+
+            tkv = encode_state.table_keys.get(self.short_name)
+            if tkv is not None and tkv != physical_value:
+                odxraise(f"Got conflicting values for table key {self.short_name}: "
+                         f"{tkv} and {physical_value!r}")
+
+            encode_state.table_keys[self.short_name] = physical_value
+
+        orig_pos = encode_state.cursor_byte_position
+        pos = encode_state.cursor_byte_position
+        if self.byte_position is not None:
+            pos = encode_state.origin_byte_position + self.byte_position
+        encode_state.key_pos[self.short_name] = pos
+        encode_state.cursor_byte_position = pos
+        encode_state.cursor_bit_position = self.bit_position or 0
+
+        key_dop = self.table.key_dop
+        if key_dop is None:
+            odxraise(f"No KEY-DOP specified for table {self.table.short_name}")
+            return
+
+        sz = key_dop.get_static_bit_length()
+        if sz is None:
+            odxraise("The DOP of table key {self.short_name} must exhibit a fixed size.",
+                     EncodeError)
+            return
+
+        # emplace a value of zero into the encode state, but pretend the bits not to be used
+        n = sz + encode_state.cursor_bit_position
+        tmp_val = b'\x00' * ((n + 7) // 8)
+        encode_state.emplace_bytes(tmp_val, obj_used_mask=tmp_val)
+
+        encode_state.cursor_byte_position = max(orig_pos, encode_state.cursor_byte_position)
+        encode_state.cursor_bit_position = 0
 
-            return bytes([0] * byte_len)
+    def encode_value_into_pdu(self, encode_state: EncodeState) -> None:
 
-        # the table key is known. We need to encode the associated DOP
-        # into the PDU.
+        key_dop = self.table.key_dop
+        if key_dop is None:
+            odxraise(
+                f"Table '{self.table.short_name}' does not define "
+                f"a KEY-DOP, but is used by TABLE-KEY parameter "
+                f"'{self.short_name}'", EncodeError)
+            return
+
+        if self.short_name not in encode_state.table_keys:
+            odxraise(f"Table key {self.short_name} has not been defined before "
+                     f"it is required.", EncodeError)
+            return
+        else:
+            tr_short_name = encode_state.table_keys[self.short_name]
+
+        # We need to encode the table key using the associated DOP into the PDU.
         tr_candidates = [x for x in self.table.table_rows if x.short_name == tr_short_name]
         if len(tr_candidates) == 0:
-            raise EncodeError(f"No table row with short name '{tr_short_name}' found")
+            odxraise(f"No table row with short name '{tr_short_name}' found", EncodeError)
+            return
         elif len(tr_candidates) > 1:
-            raise EncodeError(f"Multiple rows exhibiting short name '{tr_short_name}'")
+            odxraise(f"Multiple rows exhibiting short name '{tr_short_name}'", EncodeError)
         tr = tr_candidates[0]
 
-        key_dop = self.table.key_dop
-        if key_dop is None:
-            raise EncodeError(f"Table '{self.table.short_name}' does not define "
-                              f"a KEY-DOP, but is used in TABLE-KEY parameter "
-                              f"'{self.short_name}'")
-        bit_position = 0 if self.bit_position is None else self.bit_position
-        return key_dop.convert_physical_to_bytes(tr.key, encode_state, bit_position=bit_position)
+        encode_state.cursor_byte_position = encode_state.key_pos[self.short_name]
+        encode_state.cursor_bit_position = self.bit_position or 0
 
-    @override
-    def encode_into_pdu(self, encode_state: EncodeState) -> bytes:
-        return super().encode_into_pdu(encode_state)
+        key_dop.encode_into_pdu(encode_state=encode_state, physical_value=odxrequire(tr.key))
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         if self.table_row is not None:
             # the table row to be used is statically specified -> no
             # need to decode anything!
             phys_val = self.table_row.short_name
```

## odxtools/parameters/tablestructparameter.py

```diff
@@ -1,18 +1,17 @@
 # SPDX-License-Identifier: MIT
-import warnings
 from dataclasses import dataclass
 from typing import TYPE_CHECKING, Any, Dict, List, Optional, cast
 from xml.etree import ElementTree
 
-from typing_extensions import override
+from typing_extensions import final, override
 
 from ..decodestate import DecodeState
 from ..encodestate import EncodeState
-from ..exceptions import DecodeError, EncodeError, OdxWarning, odxraise, odxrequire
+from ..exceptions import DecodeError, EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId, OdxLinkRef
 from ..odxtypes import ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import Parameter, ParameterType
 from .tablekeyparameter import TableKeyParameter
 
 if TYPE_CHECKING:
@@ -57,23 +56,39 @@
     def _resolve_odxlinks(self, odxlinks: OdxLinkDatabase) -> None:
         super()._resolve_odxlinks(odxlinks)
 
         if self.table_key_ref is not None:
             self._table_key = odxlinks.resolve(self.table_key_ref, TableKeyParameter)
 
     @override
+    @final
     def _resolve_snrefs(self, diag_layer: "DiagLayer") -> None:
+        raise RuntimeError(f"Calling TableStructParameter._resolve_snref() is not allowed. "
+                           f"Use ._table_struct_resolve_snrefs() instead.")
+
+    def _table_struct_resolve_snrefs(self, diag_layer: "DiagLayer", *,
+                                     param_list: List[Parameter]) -> None:
         super()._resolve_snrefs(diag_layer)
 
         if self.table_key_snref is not None:
-            warnings.warn(
-                "Table keys cannot yet be defined using SNREFs"
-                " in TableStructParameters.",
-                OdxWarning,
-                stacklevel=1)
+            tk_candidates = [p for p in param_list if p.short_name == self.table_key_snref]
+            if len(tk_candidates) > 1:
+                odxraise(f"Short name reference '{self.table_key_snref}' could "
+                         f"not be uniquely resolved.")
+            elif len(tk_candidates) == 0:
+                odxraise(f"Short name reference '{self.table_key_snref}' could "
+                         f"not be resolved.")
+                return
+
+            tk = tk_candidates[0]
+            if not isinstance(tk, TableKeyParameter):
+                odxraise(f"Table struct '{self.short_name}' references non-TableKey parameter "
+                         f"`{self.table_key_snref}' as its table key.")
+
+            self._table_key = tk
 
     @property
     def table_key(self) -> TableKeyParameter:
         return self._table_key
 
     @property
     @override
@@ -82,79 +97,84 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return True
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        physical_value = encode_state.parameter_values.get(self.short_name)
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
 
-        if not isinstance(physical_value, tuple) or \
+        if not isinstance(physical_value, (tuple, list)) or \
            len(physical_value) != 2 or \
            not isinstance(physical_value[0], str):
-            raise EncodeError(f"The physical value of TableStructParameter 'self.short_name' "
-                              f"must be a tuple with  the short name of the selected table "
-                              f"row as the first element and the physical value for the "
-                              f"row's structure or DOP as the second.")
+            odxraise(
+                f"The physical value of TableStructParameter 'self.short_name' "
+                f"must be a tuple containing the short name of the selected table "
+                f"row as the first element and the physical value for the "
+                f"row's structure or DOP as the second.", EncodeError)
 
         tr_short_name = physical_value[0]
 
         # make sure that the same table row is selected for all
         # TABLE-STRUCT parameters that are using the same key
         tk_short_name = self.table_key.short_name
-        tk_value = encode_state.parameter_values.get(tk_short_name)
+        tk_value = encode_state.table_keys.get(tk_short_name)
         if tk_value is None:
             # no value for the key has been set yet. Set it to the
             # value which we are using right now
-            encode_state.parameter_values[tk_short_name] = tr_short_name
+            encode_state.table_keys[tk_short_name] = tr_short_name
         elif tk_value != tr_short_name:
-            raise EncodeError(f"Cannot determine a unique value for table key '{tk_short_name}':  "
-                              f"Requested are '{tk_value}' and '{tr_short_name}'")
+            odxraise(
+                f"Cannot determine a unique value for table key '{tk_short_name}':  "
+                f"Requested are '{tk_value}' and '{tr_short_name}'", EncodeError)
+            return
 
         # deal with the static case (i.e., the table row is selected
         # by the table key object itself)
-        if self.table_key.table_row is not None and \
-           self.table_key.table_row.short_name != tr_short_name:
-            raise EncodeError(f"The selected table row for the {self.short_name} "
-                              f"parameter must be '{self.table_key.table_row.short_name}' "
-                              f"(is: '{tr_short_name}')")
+        if self.table_key.table_row is not None:
+            if tr_short_name is not None and self.table_key.table_row.short_name != tr_short_name:
+                odxraise(
+                    f"The selected table row for the {self.short_name} "
+                    f"parameter must be '{self.table_key.table_row.short_name}' "
+                    f"instead of '{tr_short_name}'", EncodeError)
+                return
+
+            tr_short_name = self.table_key.table_row.short_name
 
         # encode the user specified value using the structure (or DOP)
         # of the selected table row
         table = self.table_key.table
         candidate_trs = [tr for tr in table.table_rows if tr.short_name == tr_short_name]
-        if len(candidate_trs) != 1:
-            raise EncodeError(f"Could not uniquely resolve a table row named "
-                              f"'{tr_short_name}' in table '{table.short_name}' ")
+        if len(candidate_trs) == 0:
+            odxraise(
+                f"Could not find a table row named "
+                f"'{tr_short_name}' in table '{table.short_name}'", EncodeError)
+            return
+        elif len(candidate_trs) > 1:
+            odxraise(
+                f"Found multiple table rows named "
+                f"'{tr_short_name}' in table '{table.short_name}'", EncodeError)
+
         tr = candidate_trs[0]
         tr_value = physical_value[1]
 
-        bit_position = self.bit_position or 0
         if tr.structure is not None:
             # the selected table row references a structure
-            inner_encode_state = EncodeState(
-                coded_message=bytearray(b''),
-                parameter_values=tr_value,
-                triggering_request=encode_state.triggering_request)
-
-            return tr.structure.convert_physical_to_bytes(
-                tr_value, inner_encode_state, bit_position=bit_position)
+            tr.structure.encode_into_pdu(tr_value, encode_state)
+            return
 
         # if the table row does not reference a structure, it must
         # point to a DOP!
         if tr.dop is None:
-            odxraise()
-
-        return tr.dop.convert_physical_to_bytes(
-            tr_value, encode_state=encode_state, bit_position=bit_position)
+            odxraise(f"Neither a structure nor a DOP has been defined for table row"
+                     f"'{tr.short_name}'")
+            return
 
-    @override
-    def encode_into_pdu(self, encode_state: EncodeState) -> bytes:
-        return super().encode_into_pdu(encode_state)
+        tr.dop.encode_into_pdu(tr_value, encode_state)
 
     @override
     def _decode_positioned_from_pdu(self, decode_state: DecodeState) -> ParameterValue:
         # find the selected table row
         key_name = self.table_key.short_name
 
         decode_state.table_keys[key_name]
```

## odxtools/parameters/valueparameter.py

```diff
@@ -3,17 +3,17 @@
 from typing import TYPE_CHECKING, Any, Dict, List, Optional
 from xml.etree import ElementTree
 
 from typing_extensions import override
 
 from ..dataobjectproperty import DataObjectProperty
 from ..encodestate import EncodeState
-from ..exceptions import odxraise, odxrequire
+from ..exceptions import EncodeError, odxraise, odxrequire
 from ..odxlink import OdxDocFragment, OdxLinkDatabase, OdxLinkId
-from ..odxtypes import AtomicOdxType
+from ..odxtypes import AtomicOdxType, ParameterValue
 from ..utils import dataclass_fields_asdict
 from .parameter import ParameterType
 from .parameterwithdop import ParameterWithDOP
 
 if TYPE_CHECKING:
     from ..diaglayer import DiagLayer
 
@@ -73,20 +73,18 @@
 
     @property
     @override
     def is_settable(self) -> bool:
         return True
 
     @override
-    def get_coded_value_as_bytes(self, encode_state: EncodeState) -> bytes:
-        physical_value = encode_state.parameter_values.get(self.short_name,
-                                                           self.physical_default_value)
+    def _encode_positioned_into_pdu(self, physical_value: Optional[ParameterValue],
+                                    encode_state: EncodeState) -> None:
+
+        if physical_value is None:
+            physical_value = self._physical_default_value
         if physical_value is None:
-            raise TypeError(f"A value for parameter '{self.short_name}' must be specified"
-                            f" as the parameter does not exhibit a default.")
-        dop = odxrequire(
-            self.dop,
-            f"Param {self.short_name} does not have a DOP. Maybe resolving references failed?")
-
-        bit_position_int = self.bit_position if self.bit_position is not None else 0
-        return dop.convert_physical_to_bytes(
-            physical_value, encode_state=encode_state, bit_position=bit_position_int)
+            odxraise(
+                f"A value for parameter '{self.short_name}' must be specified"
+                f" because the parameter does not exhibit a default.", EncodeError)
+
+        self.dop.encode_into_pdu(physical_value, encode_state=encode_state)
```

## Comparing `odxtools-6.7.1.dist-info/LICENSE` & `odxtools-7.0.0.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `odxtools-6.7.1.dist-info/METADATA` & `odxtools-7.0.0.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: odxtools
-Version: 6.7.1
+Version: 7.0.0
 Summary: Utilities to work with the ODX standard for automotive diagnostics
 Author-email: Katrin Bauer <katrin.bauer@mbition.io>, Andreas Lauser <andreas.lauser@mbition.io>, Ayoub Kaanich <kayoub5@live.com>
 Maintainer-email: Andreas Lauser <andreas.lauser@mbition.io>, Ayoub Kaanich <kayoub5@live.com>
 License: MIT
 Project-URL: Homepage, https://github.com/mercedes-benz/odxtools
 Project-URL: Bug Tracker, https://github.com/mercedes-benz/odxtools/issues
 Project-URL: Repository, https://github.com/mercedes-benz/odxtools
```

## Comparing `odxtools-6.7.1.dist-info/RECORD` & `odxtools-7.0.0.dist-info/RECORD`

 * *Files 6% similar despite different names*

```diff
@@ -1,14 +1,14 @@
 odxtools/__init__.py,sha256=-KoiS9FRLQHmg82QASRYKlfwOEbdipTeo3jWG3X9MB0,2357
 odxtools/__main__.py,sha256=MKzFqY8KAV0BGsBXs04QwPpW5OGuT-rZQ4QlM8Tar8Y,119
 odxtools/additionalaudience.py,sha256=e08SzJpxkx8Zeb9fiNWWpPuneTA7INCW9qcU335eTnQ,990
 odxtools/admindata.py,sha256=mc7yyK5yGpd1A4Rv2rv9pf9Ja-PNvB_IB1wEaIEbBNU,1919
 odxtools/audience.py,sha256=6PaZRi_-e5GDN2BZgynLWx03brvw0QgMBcl5N8heO0Y,3324
 odxtools/basecomparam.py,sha256=TTNUHm5Q8BY56HEmaK3NvDsW3K1LV6bLdxFExMJO1-I,2418
-odxtools/basicstructure.py,sha256=onq5Y0AbBrdEhDU-ScbERLBXpw3I_qEATn3rZRHIZBc,13439
+odxtools/basicstructure.py,sha256=BxZTF-vv0G8e9JcmQXvRel4BBkG2xs0x-v3Q9feaf-s,13459
 odxtools/companydata.py,sha256=RaxSq0E6kall8wZL8av5HPO9KSXLZpE_hSEIkvpzCw0,2579
 odxtools/companydocinfo.py,sha256=KLVUA-TvOnHjPYF32W8JAv8Q6LLuo6-x9u3Mj7ewBiM,2294
 odxtools/companyrevisioninfo.py,sha256=vvozMDtDZg3znZNN6Nx1MqjSsSmXtg9nY-TkF_sIHzk,1390
 odxtools/companyspecificinfo.py,sha256=1zPMQvIhj_NtkXFHz6U6bm9ExoKxLk8XdsfjhOwf5nY,1567
 odxtools/comparam.py,sha256=4GewqycflHXBOnyUJQ4octa2hdUpYVietFNs8e5stQw,1629
 odxtools/comparaminstance.py,sha256=o5Xm_H-E8902XmcurKI5BZiQjafMv-VrR6-voqgXU4I,4978
 odxtools/comparamspec.py,sha256=bEnZQpVqfDvJg3Imvh-MjzK2OY-HtJVuk3_5myMdhtk,3238
@@ -17,93 +17,93 @@
 odxtools/complexdop.py,sha256=AHkHMf_IEWfy-_zSiCuZXmdTNCXiCOpg5GRZ5uMVV5A,280
 odxtools/createanycomparam.py,sha256=RP0XA2Ut4GL2NWy05RvKBrTnpbvvCG2XuNL8OO-9rbI,617
 odxtools/createanydiagcodedtype.py,sha256=QIKSGnU6xL4DWImuXqrW6oNsWfcRphwdWi9lISgO7Lg,3770
 odxtools/createcompanydatas.py,sha256=Lkyx5gIGCozaX412GiPRUzjFOa5sZvT1LYOf_ycysdE,582
 odxtools/createecuvariantpatterns.py,sha256=FXHLGR4M791MRkpU2_keck88hoMYkuyPiCUxuGbUasQ,559
 odxtools/createsdgs.py,sha256=tPdkPN4cHBWGddMWb7QLvyUIA9boa87da2Aj_2m3C2o,531
 odxtools/database.py,sha256=030VDfHpvICWP8jagJlRm5z1AM5VC_LlJZydiY3sBw4,6741
-odxtools/dataobjectproperty.py,sha256=B5g4OTMCbgy40-KMY1wWTA-Nx1KaqcdwBogq5mWSNxk,6324
-odxtools/decodestate.py,sha256=at3ISfhn7AKMJbHxnfuxuxL4sOvdC19t40cEVYOUO-k,4883
+odxtools/dataobjectproperty.py,sha256=JeQUaM2eO_WrZUSlqMJAYk9J0-gK8epz8NqUVOD-Rz8,6146
+odxtools/decodestate.py,sha256=mgr9dmn8dM7jU6Y7en_Bf8lAx4HHMlpsdbVup5qqgzw,4490
 odxtools/determinenumberofitems.py,sha256=9MlJgWnvGtOLGou1IU5suYdbMesRngyTPSgb7As6LIU,1561
-odxtools/diagcodedtype.py,sha256=IWzx_em8aj8KGo1xvwidq6Fk1zJZYxsbXPG9yCsnYLA,7409
+odxtools/diagcodedtype.py,sha256=trrZfgoxnui3AC42XeUzfz2THq-wwnFMPr6AKOqN3YU,3673
 odxtools/diagcomm.py,sha256=nS57xwrArzU22jbgJ5io7zpmq2P0Qz8fxnbqb60VIJg,7623
 odxtools/diagdatadictionaryspec.py,sha256=v9Tg2C_rjXQGJG1BdrIkYPQYZGxcyTUHxQ6f5BsTEwU,10615
-odxtools/diaglayer.py,sha256=9Y-p_qfQbt2Dqoc62RnYfMrm-sEZZX4VB1FQx8XdDcM,45120
+odxtools/diaglayer.py,sha256=w3E9gKHfavL20QvxOViTuXMDonqWibg0qSYPpL6wVKY,47279
 odxtools/diaglayercontainer.py,sha256=1Kq6vVp_Bu9qpwN4kdoRU-bm9L5McwcKPBQn1z81RCI,5877
 odxtools/diaglayerraw.py,sha256=RMDB-Dv0_bOeju0FuDZ2goB53HOjF97U-qKgel6vVM0,13945
 odxtools/diaglayertype.py,sha256=FXL-EVBdrAURuHSHo9OthFuEYEybQO66aMB1o2GxVdI,1340
 odxtools/diagnostictroublecode.py,sha256=FD1wDdNbA53PAj16JO0NfNgHddQ4csv_ldIwIUBoRwo,2496
-odxtools/diagservice.py,sha256=TtY9kN3idjcGjkHWOwncWbltDaSG1X14ZjT-0yqrwBQ,9788
+odxtools/diagservice.py,sha256=2ULG0ssEZJH_XRuNqsLaTCzVWMEemwdhxys3fDSYjyg,9609
 odxtools/docrevision.py,sha256=NKrOSaoz5GJwi4UXlrGYa1EOhMqZKcOCFT38c5VzU4k,2738
-odxtools/dopbase.py,sha256=66q77rZeix5KULIMiLR9hcYwedvByT7vspbbU96riT4,2635
-odxtools/dtcdop.py,sha256=YSRe0NUHWEyOHaCkmd3SXQT0WHXcrO3FWNS7Lute-Zc,7504
-odxtools/dynamiclengthfield.py,sha256=sS3ZHm4PZjYo-T-UANMRXYtu1xOOuRgl2O_gXAP4WiY,5020
+odxtools/dopbase.py,sha256=UKoPhG8HkaTh2UFXKSMwK-StAnMy9pdZ_IMRtz-gvCs,2520
+odxtools/dtcdop.py,sha256=4VvgwFhXF5HlIedc2ad8cRXIrdW4x27xjJEbpDfaL3g,7456
+odxtools/dynamiclengthfield.py,sha256=_dFS9DLpqVmoi8mb-oXFynya8E8UUrezvvkQrEGUQLg,5324
 odxtools/ecuvariantmatcher.py,sha256=FO85WesRmkssSsTrjW8Ehg87FRmv1oHTkH5jPwumWYI,6882
 odxtools/ecuvariantpattern.py,sha256=Xp2NpS13sVvyOjy2PgxLvXPptAfmYSH_KDIjqYByZHs,863
 odxtools/element.py,sha256=JLLpie8XmnMrUFR1nX9PUXoBmU60tfoSI5p7-QjCXQE,1209
-odxtools/encodestate.py,sha256=8YyqnCrVhcZu_EmE1ZaF3TCycn-IJfkU-dAjSxYeMT4,2131
-odxtools/endofpdufield.py,sha256=ibGmi3s_snwJK4zjn8Zl-JtznlJ0oirLE51oYN98iFo,2801
+odxtools/encodestate.py,sha256=8pcn8MRumClpvyofWtXcBZzRqDn9v0kcmAvy84z15dI,9378
+odxtools/endofpdufield.py,sha256=uls3ViSbhLBWMfq2jPfuVs-jASwL-4eX21c_bKgk3oI,2747
 odxtools/environmentdata.py,sha256=r6sUlm0C-DeSbE-WhkLf51O5ja8TquqdW-vdNI4gaDY,1144
-odxtools/environmentdatadescription.py,sha256=jnnhca0zgvwVIXJIil8oO4IkfjBLiG6BL_93JWCQJJc,4347
+odxtools/environmentdatadescription.py,sha256=QoE8jMSKdm-wBZv_b4AaqXxQtACho1Ec8NkunBELUSg,4181
 odxtools/exceptions.py,sha256=FgS11U7ABMnc7T602bE1XMBLj9P0oDwwdpp-L3NafGY,2505
 odxtools/field.py,sha256=M8tv1-N9TaZGCMv77pTJSvseHW8hh7o-8cIOB3QeCM0,3829
 odxtools/functionalclass.py,sha256=Rrnpqm-wTRc7TUfnKfiOeOi1XrvKB9TN2HiXtCU2YLY,985
 odxtools/globals.py,sha256=P6YbgyTSWHMw3sk5cEzsCvVaLrTiakLvewTgySb1jLo,139
 odxtools/inputparam.py,sha256=yQk23WBv4bFWI3nW1yv0dORf-Jso9sf1Zms7CyQaPGc,1875
 odxtools/internalconstr.py,sha256=QKEkaOcrFoL9xID-oHWWkeg-vtcPV6RFOW1fX2K3pwg,1363
 odxtools/isotp_state_machine.py,sha256=O6v29IK7p_4gFqrr-fahnbp9Qmo78EEQfEwRsA_Vfjw,13339
-odxtools/leadinglengthinfotype.py,sha256=60hK3tLv6NeZqrmd4idzWa-aGFsrUzGmCWx2EyBhOqk,3171
+odxtools/leadinglengthinfotype.py,sha256=Dg_dNySVoYsKWCSKrStLDobvNiSXRTCSlYYXnlXP_DY,3664
 odxtools/load_file.py,sha256=H-cnL2cwVmxIirvm5onzhq-fSxNjSmVaQr7ZrXZHjtE,461
 odxtools/load_odx_d_file.py,sha256=QBVa9r9L4s6ffNWd_LM7NJq2WCxdsJs_EU0RzqgRYrk,172
 odxtools/load_pdx_file.py,sha256=Eo4cIYWzqe_w1w4LQ-aqNPfHG-hJaxmigOs4y_ZlVlU,186
 odxtools/matchingparameter.py,sha256=QWiWlwzJWJc0UWilkhoFyGkAey80MvA_WDsuRdaT5HA,2229
 odxtools/message.py,sha256=07GekN1MbYXm7HaUITDKTj2lBmGK-LB9W8gtBmfAOew,1057
-odxtools/minmaxlengthtype.py,sha256=ryH7uMWvHxnJwRdXaOICO4qaN4unqgb3jMHt44KlOWo,7879
+odxtools/minmaxlengthtype.py,sha256=fAF5FX2PahOm5Z-C1bo5taedxxL8YUAdBFjCeDFS_-o,8114
 odxtools/modification.py,sha256=zO_vdbLnAM876VNyX53rGrUrG4YaKDq799Y3xzrsEyg,872
-odxtools/multiplexer.py,sha256=9oVduCSlr-gT4Vwb8gws4YuzFkns9yAeD_baFdP1FQQ,7618
-odxtools/multiplexercase.py,sha256=gktKeyp_QdjkhtaiCSO67uOYDS5t1KwiseCaO9crE8E,3126
+odxtools/multiplexer.py,sha256=8mEaBseTY4OAbEC5RcpdROnq4uG3yiMyvAShZza-r7M,8354
+odxtools/multiplexercase.py,sha256=Zh8E0zPcur-2ZQVf5CEHeQCbQx0r7-df0QrTKDfNelc,3124
 odxtools/multiplexerdefaultcase.py,sha256=F13aTRZAriGatM-Rv-t-rqEqTriADkigHTLfE317BJk,1979
 odxtools/multiplexerswitchkey.py,sha256=jvX8b9hM1XRwet20AvtsYXZZt137M0rTjLFLKhtF43M,1554
-odxtools/nameditemlist.py,sha256=jbhpo27af1cFij6ULsrmtUaN6uwjG-N9W2GGJeioDEA,6164
+odxtools/nameditemlist.py,sha256=JgolDW_PCa5tHjGIGBwzhWtcre6JisVvv3onFk3dGKE,6539
 odxtools/negoutputparam.py,sha256=QJ4X4Nlo2MbBi7VbOjBvD32gTDLPpF1l6NjChzikh-k,1407
 odxtools/obd.py,sha256=WsUbhdonqQJtxf972CUdYL78AMMTVjMQhoCJbaZhRIo,1860
 odxtools/odxlink.py,sha256=DgysSkAWflTHAp-m5VGPKnDiku4ntnsti1iAhyHRvVY,8932
-odxtools/odxtypes.py,sha256=Q8RkINFzIrCwpdNzUSczsnIL58OrGqEVPOZ-n3xQWkc,7036
+odxtools/odxtypes.py,sha256=sBIpCLWzyLdGlwEzqB3h9uTO5utoL_j82gEfKdNCbvA,7495
 odxtools/outputparam.py,sha256=R_pVosDwE-7-l3JAV3CRhsGEKRRnVjv80fnRlZUncI4,1670
-odxtools/parameterinfo.py,sha256=ExYMhG_u_jl7DHe_W78Lnf6RW3dxVejtPV1KBjbk7CM,3951
-odxtools/paramlengthinfotype.py,sha256=-q1IP1fQ3YPQmwQEytiTQ2bC12ttD01VTPTBJkoE4cc,3718
+odxtools/parameterinfo.py,sha256=mnGCe_LpVKghVRSQWut3mznFfdE9wLJQbA6Xz_Hn0Q8,8147
+odxtools/paramlengthinfotype.py,sha256=fjlFd-AEVAiEnEuVEdGiIQoaFjQPDI10ZNDqRznggfU,4155
 odxtools/parentref.py,sha256=dvHJji5NabfdDX-JZ9IQNfrU0JVNnkuH8eWWg7XvaCk,3316
 odxtools/physicaldimension.py,sha256=gvgYoeY7dTujDv_H5XW6S8lvGQadAPUlau6YD_KRJ84,3393
 odxtools/physicaltype.py,sha256=oYjOhdrTVCJcLLBYgy6pxKsZHpuwm1vZ8svwSjsUB6E,2699
 odxtools/progcode.py,sha256=vIra_TU34YCa-YKvdvc3cywZMQBWSEg2ugMS6dNJUoI,1765
 odxtools/protstack.py,sha256=Sf3gdvBLQbsdFOsN2shUtBs5SfjGzu8pLz_3td9ugxw,2046
 odxtools/relateddoc.py,sha256=jbBMEYycGF0TqwxNKibWyA9r6fFAWHS5lA-tN0El9QI,1335
-odxtools/request.py,sha256=SYyJAJAp3FieKIn4bIxHcAAws3kacX0DQZALnVtg_34,719
-odxtools/response.py,sha256=c-5ohQoBTP1JVnUqptR86eIXBl5VnttSWdui4tKDvNs,2030
+odxtools/request.py,sha256=-juV4Vpoe7TTjMa1ys6e2qqKSAepvfYVEQ84XEOE0ZA,1029
+odxtools/response.py,sha256=qOUAorH44MaZ_Dyxy5casIabJJCUg9ZjX_1puBljLow,1599
 odxtools/scaleconstr.py,sha256=9SmUv-h3e4cOglTDJwEyT9Fz-LRFrPLGPha27-Ygndk,1780
 odxtools/servicebinner.py,sha256=ijFp5CqU5PO0Wx_YFtJB8tQigMLhg9TYu78BQELoet0,3859
 odxtools/singleecujob.py,sha256=ZY16lxvkCR4KrdviB7IXwqGRF8Z5tXZxG4MgLWHdmdw,3891
 odxtools/specialdata.py,sha256=3E-KxtoCUpHeaiMH6Zp4jivALkCsNaTlZ9KROcCDWnE,1067
 odxtools/specialdatagroup.py,sha256=KP3vy8BqeTA_qZcmteAmV7ckC65zjpI3B1hKXyzctJI,3077
 odxtools/specialdatagroupcaption.py,sha256=AVUA1M-EXPA9k_EqOAZWajRIhQdGKp_HlLXlre2ZDhE,1039
-odxtools/standardlengthtype.py,sha256=eVZd72knF2tTlGkIPgTX4CC7h7lgRXxuffA7qo0EBRU,2433
+odxtools/standardlengthtype.py,sha256=RFbntOwZHZTGwJ8YdbkPSeUD_-d6uQLrupc-wlPwcus,3876
 odxtools/state.py,sha256=os5HJvZj7_2zutJhyiq701JA_CSpyS1C6XJKHFWEKVY,932
 odxtools/statechart.py,sha256=fksrDgmldajQ3eXU99sEcFfAp5gaNS5g3Fb5VbBM50I,3246
 odxtools/statetransition.py,sha256=pCH-WjCIiIKVBpBYfBp9ie6TBSUO_lPvPE3CAmgM3XU,2206
-odxtools/staticfield.py,sha256=InE7nSk-RY_kr7BOTOo8LKys_UAKLP0AUoTuif-TM6Q,3846
+odxtools/staticfield.py,sha256=HRwdM1CFpCz7fk4K5hC9i5_0HEmOmfeQpYcxcv9AntQ,3994
 odxtools/structure.py,sha256=W8uX1YQuJUApKfeLxYqlnU3EZ3AjTqcYpCUStR43ORI,582
 odxtools/table.py,sha256=lgsamAWOKuw0ym-6LQjYjpoH_iglx2PRwHn0CvJ5hu4,4051
 odxtools/tablerow.py,sha256=4PBOcfJIOzK3WVtmr_mssf7NlD4hh-6agkOBSwFApSQ,6149
 odxtools/teammember.py,sha256=nhpTD7TYoixKe-K2MDoyYP4K_xlmWQtAxTm4Srh4CLo,1806
 odxtools/uds.py,sha256=69SyVnQDcyspzSf6QVfm_Uk9iCxczD6UcrO1PxhNo7E,5894
 odxtools/unit.py,sha256=Yhf8Q2PkOnOImO7C7nehS59ua6kWd2da73VRQ0xNRfU,3701
 odxtools/unitgroup.py,sha256=HCFwmUR_-N1_bfcDQiWV2rq29uRQWbVMbxSASw8P8ow,2101
 odxtools/unitspec.py,sha256=WFifnGPLfaRzCUpZNY8lvB5_jXuoGJuvKcyL1R04oJ0,2981
 odxtools/utils.py,sha256=JeUgIYnxysVELmSYbKH49IC9dU6B31Cwoo85Ag10V74,1983
-odxtools/version.py,sha256=v91MbC56MHoAoT4fOiMyGx_etT2swZvPR4v--skkB1A,411
+odxtools/version.py,sha256=b2opXya2curUayumThwB1n8tjaCRTcILs1KIQk3ehHk,411
 odxtools/write_pdx_file.py,sha256=qx02oe-BFJ0lmDJMh5tR0qS5mpzalUV6vVP2eXtjaBo,7307
 odxtools/xdoc.py,sha256=pUYo6l60ns9LOEdutE06WMcNy25yNVl1Ni4lMpYt1pY,1467
 odxtools/cli/__init__.py,sha256=T7ano_FIyzBASxYpmcA5VJXU5bQLIy_Qk0HE_SDKelY,106
 odxtools/cli/_parser_utils.py,sha256=hI1PndAaA-AXBrjev71OSZVpbfuBebNYvxG6XdMSM50,1117
 odxtools/cli/_print_utils.py,sha256=AVqvL88EzHclY2YJicdF-wxsCHXhCqByATd7wt8S12s,10284
 odxtools/cli/browse.py,sha256=hvGcwJ_zgJ7H-p9ShhaoH4XeYR2wICpxXFF5nkftIMc,15797
 odxtools/cli/compare.py,sha256=-kNv13vgSPSNmUdnaRf1io3ABYwGyIctrd9cYsJZe78,36768
@@ -119,29 +119,29 @@
 odxtools/compumethods/createanycompumethod.py,sha256=LhLD8v5RZ4_PIT29OdRIiLFqLTlMQND1We85gwVZBB4,7154
 odxtools/compumethods/identicalcompumethod.py,sha256=WjqizY0RH20S3vXg-iKbFttka3efTr2J420b3_Dj-ck,830
 odxtools/compumethods/limit.py,sha256=QjrY6dd0Kc7n4CcweMBrkwlX4hsmx0bkQEaQKmTxQ18,4164
 odxtools/compumethods/linearcompumethod.py,sha256=kW_siDBRdfNXZLdll1kUFd6sAgXdtIsQXR3uxZ8uwPU,7690
 odxtools/compumethods/scalelinearcompumethod.py,sha256=ZUY6JRuIIWkCfHR0b3WOBlvAspmaz4oIbJtiEMg34Hk,1644
 odxtools/compumethods/tabintpcompumethod.py,sha256=BY1uSwwfsfj6GaBoLpmiHTvSnYZFWIpFybWH2jZk3f0,7302
 odxtools/compumethods/texttablecompumethod.py,sha256=ICDyTTuOcZDzCexbVOLYLjc4XwwS3G7W2R8UJBLstfE,3347
-odxtools/parameters/codedconstparameter.py,sha256=wLayKz98zpcvqSLEpL6GCfTP5VmsBOhKW1sjwxjSozc,4213
+odxtools/parameters/codedconstparameter.py,sha256=Bs4O8R66zboutJOmM7VLSVijWs0ZO_vUCD7O4qxw1C4,4232
 odxtools/parameters/createanyparameter.py,sha256=m26HHUQrxwDak3eBBciVBLic768Qlo4F2xn1z3r0boM,2566
-odxtools/parameters/dynamicparameter.py,sha256=3KHQRVyAB7emZnHOhWhncC_JZJSTAMnTKfMeyKLgoKs,1483
-odxtools/parameters/lengthkeyparameter.py,sha256=zVg2C9NENgESi4E_N4GXRMvkIeFex4UM7aOsK4oN0Ng,3375
-odxtools/parameters/matchingrequestparameter.py,sha256=BYT20ho08QCtiFhyHXMcMHQtO-fKKB8NmY_ytmqu1u0,2354
-odxtools/parameters/nrcconstparameter.py,sha256=n77raakhDWW8vM5kdlIywJbf990GhX76wBCxZ481Tlo,4749
-odxtools/parameters/parameter.py,sha256=4oCcWnomeBv0rIPVq5wNk2FYSscyvmmUxuOR7MBUvfo,6306
-odxtools/parameters/parameterwithdop.py,sha256=-QAcx1XEheRF_C2FnOJOR0f-G0tBP7I2ZaZmge05iqc,3757
-odxtools/parameters/physicalconstantparameter.py,sha256=BCNek_yBb37ZGM4Yjy4sGiGHWTD-NxVCMDF2ItV5-Po,3759
-odxtools/parameters/reservedparameter.py,sha256=64FGgZ2ZAmZLNghewYbiIDZw9bkBPuTGszB0-1k_Wu4,1744
-odxtools/parameters/systemparameter.py,sha256=yWjKzf5IzrKX_8a18h6leez4FPKM7egGO1SMtYFonZA,1694
-odxtools/parameters/tableentryparameter.py,sha256=mdt8L3TKzuEf1_NmLUpuDhasQ-maqYdSQ3WAJlmplhQ,2324
-odxtools/parameters/tablekeyparameter.py,sha256=rexy27Rh-UHbzrxC1xwBo_hr1bsTE7UsaCqjEqfI1xM,7700
-odxtools/parameters/tablestructparameter.py,sha256=B7clyvqbGFzY_JomJ5cLI9wXu0oqfwM9EVmPWvWO-2s,7148
-odxtools/parameters/valueparameter.py,sha256=CpRAm2x0adtXyX38R68L-JWXhsbhJGjXk2TlyszCzxc,3330
+odxtools/parameters/dynamicparameter.py,sha256=mdZx12XbhTSYVVuXEsPYRll3zaHjbHIYIzA6yUy4zck,1569
+odxtools/parameters/lengthkeyparameter.py,sha256=I7DZ3MJiUTwzEXVO02swjdMFrZUx__ly3_yz5Wu-cvU,5761
+odxtools/parameters/matchingrequestparameter.py,sha256=VNYIpmP_Yt_pzMHPgGWZk1XYH5liIdyawNIwIR1Cbvw,2897
+odxtools/parameters/nrcconstparameter.py,sha256=EsQX3jTaVlbYB7A5vTaFqT19YptQmwzdf0kmd_O-3Zo,5589
+odxtools/parameters/parameter.py,sha256=BBkJNTNMtqHrMXNL-ov-YDCjEhVeKWIqrYCBbBpia4w,5955
+odxtools/parameters/parameterwithdop.py,sha256=b8kwMsbW76XMAzJ040Lkpi9mI5pxgauGOcFNwnekLQY,3595
+odxtools/parameters/physicalconstantparameter.py,sha256=W3f5HcdLXgPxRFZUIQjr4t2FNgI8rAA65M5RMtD9D40,3630
+odxtools/parameters/reservedparameter.py,sha256=GSwTZh5Gc_QTiVPfHJSwCDX1rAOke5KEFcEzTRJRRZc,1930
+odxtools/parameters/systemparameter.py,sha256=AFhyd7KxVzAjrOxgpq7PMGjo4gFd26ABxTAyaA46bbs,1784
+odxtools/parameters/tableentryparameter.py,sha256=SuNAFn1wN_hyO2MVd1lT3oQllZ6nLjAIBJHX0HYRyko,2414
+odxtools/parameters/tablekeyparameter.py,sha256=A7sOc1fEKpJ3Ey82rgM8zLIKeCUUQZKM3cVU8KJhca0,9768
+odxtools/parameters/tablestructparameter.py,sha256=Bzd2oIekC8cZ4yQIu1DNW3j97h68Wzpfk6imEKkcyK0,7977
+odxtools/parameters/valueparameter.py,sha256=Wdg19WyFfMqcJAE3OtAJv_n3YtZGXgmeTosVJ6rpJtw,3100
 odxtools/templates/comparam-spec.odx-c.xml.jinja2,sha256=6EFYwQP5H1prtygR4-1FA8O-GsInRj8QVfWbdN_H0ss,1562
 odxtools/templates/comparam-subset.odx-cs.xml.jinja2,sha256=z7eCUbreEx5nUosus2jyyluz4L3j1e2iKA3eZU9KlEc,2522
 odxtools/templates/diag_layer_container.odx-d.xml.jinja2,sha256=nr1LMD8_fJF7rNaq1gERufbgf36aHqfzD95kg4sMQCc,2026
 odxtools/templates/index.xml.xml.jinja2,sha256=dX7QZA3G5Au2BMbXWMMyF2K1aR6i3go-0E5dY3Z9hWE,636
 odxtools/templates/macros/printAdminData.xml.jinja2,sha256=YTB_CbhnALF6RIbE0XKQHRbC6c0PSZ_DxdrRHgqMD_s,2590
 odxtools/templates/macros/printAudience.xml.jinja2,sha256=IiAogxtEIo6qg7iZm1plQtrM4nkl6jj9GhIv5QI5ETM,1278
 odxtools/templates/macros/printBasicStructure.xml.jinja2,sha256=V5oWGZesU_U5pvPO3Rtlodc7sxe5mFWY-uURLnQ8OfQ,614
@@ -170,13 +170,13 @@
 odxtools/templates/macros/printStateChart.xml.jinja2,sha256=bOj9FWl-kZmlhoMskG71zS9NxtTimGwQvgDpKNaPw6s,943
 odxtools/templates/macros/printStateTransition.xml.jinja2,sha256=iO4fSCwFMLdX_VDdNnn8udiGE3vYU7tXPfbEBvoTFa4,502
 odxtools/templates/macros/printStaticField.xml.jinja2,sha256=JIXFhyNrnQ-2_vWy6RxikrYpp5ZMAITgWCVCnt7bOxQ,513
 odxtools/templates/macros/printStructure.xml.jinja2,sha256=uswYs2xse0B9hZut_FN1GvvR0xsZa_3pZRnlF0ElEEc,559
 odxtools/templates/macros/printTable.xml.jinja2,sha256=DGd-TolTeBFoDuowd_KW0ZZT_etKRjwq9lia0yXror4,1466
 odxtools/templates/macros/printUnitSpec.xml.jinja2,sha256=AJ5jWYKRmoIZkrd25R1KmjjgU6pfOqRiOQHtUAuS6GI,2813
 odxtools/templates/macros/printVariant.xml.jinja2,sha256=kL3wZG2S7OlKQI3YMTRUYOBJBbVjulruR_bt9WOEiks,6934
-odxtools-6.7.1.dist-info/LICENSE,sha256=NeGPFQdTa6EKeON3aShVlPAIquJnbbiOfj0suz6rzyQ,1074
-odxtools-6.7.1.dist-info/METADATA,sha256=ZtPoKih9DmpbnUT7qW9bzmzGIdRtBJk9pUQod0PbTIQ,44108
-odxtools-6.7.1.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
-odxtools-6.7.1.dist-info/entry_points.txt,sha256=_sBDzuNoT8LbbCjfc-OJiUt5WPrtOq_x-rr9txhrPjY,53
-odxtools-6.7.1.dist-info/top_level.txt,sha256=pdS02kE5ZdgsaBRZDpX3NBFlaSx3zotsqX4E4V6tXEI,9
-odxtools-6.7.1.dist-info/RECORD,,
+odxtools-7.0.0.dist-info/LICENSE,sha256=NeGPFQdTa6EKeON3aShVlPAIquJnbbiOfj0suz6rzyQ,1074
+odxtools-7.0.0.dist-info/METADATA,sha256=NQ5fyJSBJ9kWAiJmdDjKHwH-i7Vr8GedPHlnB77HJUo,44108
+odxtools-7.0.0.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+odxtools-7.0.0.dist-info/entry_points.txt,sha256=_sBDzuNoT8LbbCjfc-OJiUt5WPrtOq_x-rr9txhrPjY,53
+odxtools-7.0.0.dist-info/top_level.txt,sha256=pdS02kE5ZdgsaBRZDpX3NBFlaSx3zotsqX4E4V6tXEI,9
+odxtools-7.0.0.dist-info/RECORD,,
```

