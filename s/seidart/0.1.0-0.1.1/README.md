# Comparing `tmp/seidart-0.1.0-cp311-cp311-win_amd64.whl.zip` & `tmp/seidart-0.1.1-cp311-cp311-win_amd64.whl.zip`

## zipinfo {}

```diff
@@ -1,29 +1,29 @@
-Zip file size: 789436 bytes, number of entries: 27
--rw-rw-rw-  2.0 fat      127 b- defN 24-Apr-14 16:10 seidart/__init__.py
--rw-rw-rw-  2.0 fat  1043789 b- defN 24-Apr-14 16:12 seidart/.libs/libcpmlfdtd.AP6PGGFW2QZKYFCDZKTSOH6GOIU3KKZG.gfortran-win_amd64.dll
--rw-rw-rw-  2.0 fat   713500 b- defN 24-Apr-14 16:12 seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll
--rw-rw-rw-  2.0 fat       17 b- defN 24-Apr-14 16:10 seidart/fortran/__init__.py
--rw-rw-rw-  2.0 fat    62464 b- defN 24-Apr-14 16:12 seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat    35840 b- defN 24-Apr-14 16:12 seidart/fortran/orientsynth.cp311-win_amd64.pyd
--rw-rw-rw-  2.0 fat      232 b- defN 24-Apr-14 16:10 seidart/routines/__init__.py
--rw-rw-rw-  2.0 fat    17771 b- defN 24-Apr-14 16:10 seidart/routines/arraybuild.py
--rw-rw-rw-  2.0 fat    51325 b- defN 24-Apr-14 16:10 seidart/routines/definitions.py
--rw-rw-rw-  2.0 fat    35180 b- defN 24-Apr-14 16:10 seidart/routines/materials.py
--rw-rw-rw-  2.0 fat     3939 b- defN 24-Apr-14 16:10 seidart/routines/orientation_tensor.py
--rw-rw-rw-  2.0 fat     9671 b- defN 24-Apr-14 16:10 seidart/routines/prjbuild.py
--rw-rw-rw-  2.0 fat    21632 b- defN 24-Apr-14 16:10 seidart/routines/prjrun.py
--rw-rw-rw-  2.0 fat     9871 b- defN 24-Apr-14 16:10 seidart/routines/sourcefunction.py
--rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-14 16:10 seidart/simulations/__init__.py
--rw-rw-rw-  2.0 fat     1430 b- defN 24-Apr-14 16:10 seidart/simulations/common_offset.py
--rw-rw-rw-  2.0 fat       46 b- defN 24-Apr-14 16:10 seidart/visualization/__init__.py
--rw-rw-rw-  2.0 fat     7092 b- defN 24-Apr-14 16:10 seidart/visualization/im2anim.py
--rw-rw-rw-  2.0 fat    13729 b- defN 24-Apr-14 16:10 seidart/visualization/imgen.py
--rw-rw-rw-  2.0 fat     1291 b- defN 24-Apr-14 16:10 seidart/visualization/implot.py
--rw-rw-rw-  2.0 fat     5280 b- defN 24-Apr-14 16:10 seidart/visualization/slice25d.py
--rw-rw-rw-  2.0 fat     4088 b- defN 24-Apr-14 16:10 seidart/visualization/vtkbuild.py
--rw-rw-rw-  2.0 fat    35823 b- defN 24-Apr-14 16:12 seidart-0.1.0.dist-info/LICENSE.txt
--rw-rw-rw-  2.0 fat    48376 b- defN 24-Apr-14 16:12 seidart-0.1.0.dist-info/METADATA
--rw-rw-rw-  2.0 fat      102 b- defN 24-Apr-14 16:12 seidart-0.1.0.dist-info/WHEEL
--rw-rw-rw-  2.0 fat        8 b- defN 24-Apr-14 16:12 seidart-0.1.0.dist-info/top_level.txt
--rw-rw-r--  2.0 fat     2451 b- defN 24-Apr-14 16:12 seidart-0.1.0.dist-info/RECORD
-27 files, 2125074 bytes uncompressed, 785432 bytes compressed:  63.0%
+Zip file size: 941709 bytes, number of entries: 27
+-rw-rw-rw-  2.0 fat      127 b- defN 24-Apr-29 18:05 seidart/__init__.py
+-rw-rw-rw-  2.0 fat  1455789 b- defN 24-Apr-29 18:07 seidart/.libs/libcpmlfdtd.HHM64BD6ITWEAQBB4CKPKFCVIIT6G6AX.gfortran-win_amd64.dll
+-rw-rw-rw-  2.0 fat   713500 b- defN 24-Apr-29 18:07 seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll
+-rw-rw-rw-  2.0 fat       17 b- defN 24-Apr-29 18:05 seidart/fortran/__init__.py
+-rw-rw-rw-  2.0 fat    73728 b- defN 24-Apr-29 18:07 seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat    35840 b- defN 24-Apr-29 18:07 seidart/fortran/orientsynth.cp311-win_amd64.pyd
+-rw-rw-rw-  2.0 fat      232 b- defN 24-Apr-29 18:05 seidart/routines/__init__.py
+-rw-rw-rw-  2.0 fat    18014 b- defN 24-Apr-29 18:05 seidart/routines/arraybuild.py
+-rw-rw-rw-  2.0 fat    51433 b- defN 24-Apr-29 18:05 seidart/routines/definitions.py
+-rw-rw-rw-  2.0 fat    35262 b- defN 24-Apr-29 18:05 seidart/routines/materials.py
+-rw-rw-rw-  2.0 fat     3939 b- defN 24-Apr-29 18:05 seidart/routines/orientation_tensor.py
+-rw-rw-rw-  2.0 fat     9671 b- defN 24-Apr-29 18:05 seidart/routines/prjbuild.py
+-rw-rw-rw-  2.0 fat    21596 b- defN 24-Apr-29 18:05 seidart/routines/prjrun.py
+-rw-rw-rw-  2.0 fat     9871 b- defN 24-Apr-29 18:05 seidart/routines/sourcefunction.py
+-rw-rw-rw-  2.0 fat        0 b- defN 24-Apr-29 18:05 seidart/simulations/__init__.py
+-rw-rw-rw-  2.0 fat     8201 b- defN 24-Apr-29 18:05 seidart/simulations/common_offset.py
+-rw-rw-rw-  2.0 fat       46 b- defN 24-Apr-29 18:05 seidart/visualization/__init__.py
+-rw-rw-rw-  2.0 fat     7092 b- defN 24-Apr-29 18:05 seidart/visualization/im2anim.py
+-rw-rw-rw-  2.0 fat    13729 b- defN 24-Apr-29 18:05 seidart/visualization/imgen.py
+-rw-rw-rw-  2.0 fat     1291 b- defN 24-Apr-29 18:05 seidart/visualization/implot.py
+-rw-rw-rw-  2.0 fat     5280 b- defN 24-Apr-29 18:05 seidart/visualization/slice25d.py
+-rw-rw-rw-  2.0 fat     4088 b- defN 24-Apr-29 18:05 seidart/visualization/vtkbuild.py
+-rw-rw-rw-  2.0 fat    35823 b- defN 24-Apr-29 18:07 seidart-0.1.1.dist-info/LICENSE.txt
+-rw-rw-rw-  2.0 fat    48376 b- defN 24-Apr-29 18:07 seidart-0.1.1.dist-info/METADATA
+-rw-rw-rw-  2.0 fat      102 b- defN 24-Apr-29 18:07 seidart-0.1.1.dist-info/WHEEL
+-rw-rw-rw-  2.0 fat        8 b- defN 24-Apr-29 18:07 seidart-0.1.1.dist-info/top_level.txt
+-rw-rw-r--  2.0 fat     2451 b- defN 24-Apr-29 18:07 seidart-0.1.1.dist-info/RECORD
+27 files, 2555506 bytes uncompressed, 937705 bytes compressed:  63.3%
```

## zipnote {}

```diff
@@ -1,11 +1,11 @@
 Filename: seidart/__init__.py
 Comment: 
 
-Filename: seidart/.libs/libcpmlfdtd.AP6PGGFW2QZKYFCDZKTSOH6GOIU3KKZG.gfortran-win_amd64.dll
+Filename: seidart/.libs/libcpmlfdtd.HHM64BD6ITWEAQBB4CKPKFCVIIT6G6AX.gfortran-win_amd64.dll
 Comment: 
 
 Filename: seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll
 Comment: 
 
 Filename: seidart/fortran/__init__.py
 Comment: 
@@ -60,23 +60,23 @@
 
 Filename: seidart/visualization/slice25d.py
 Comment: 
 
 Filename: seidart/visualization/vtkbuild.py
 Comment: 
 
-Filename: seidart-0.1.0.dist-info/LICENSE.txt
+Filename: seidart-0.1.1.dist-info/LICENSE.txt
 Comment: 
 
-Filename: seidart-0.1.0.dist-info/METADATA
+Filename: seidart-0.1.1.dist-info/METADATA
 Comment: 
 
-Filename: seidart-0.1.0.dist-info/WHEEL
+Filename: seidart-0.1.1.dist-info/WHEEL
 Comment: 
 
-Filename: seidart-0.1.0.dist-info/top_level.txt
+Filename: seidart-0.1.1.dist-info/top_level.txt
 Comment: 
 
-Filename: seidart-0.1.0.dist-info/RECORD
+Filename: seidart-0.1.1.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll

### objdump

```diff
@@ -5,15 +5,15 @@
 
 Characteristics 0x2026
 	executable
 	line numbers stripped
 	large address aware
 	DLL
 
-Time/Date		Sun Apr 14 16:12:40 2024
+Time/Date		Mon Apr 29 18:07:08 2024
 Magic			020b	(PE32+)
 MajorLinkerVersion	2
 MinorLinkerVersion	39
 SizeOfCode		000000000004c200
 SizeOfInitializedData	0000000000060a00
 SizeOfUninitializedData	0000000000000e00
 AddressOfEntryPoint	0000000000001320
@@ -26,15 +26,15 @@
 MajorImageVersion	0
 MinorImageVersion	0
 MajorSubsystemVersion	5
 MinorSubsystemVersion	2
 Win32Version		00000000
 SizeOfImage		0008e000
 SizeOfHeaders		00000600
-CheckSum		000af180
+CheckSum		000bb44f
 Subsystem		00000003	(Windows CUI)
 DllCharacteristics	00000160
 					HIGH_ENTROPY_VA
 					DYNAMIC_BASE
 					NX_COMPAT
 SizeOfStackReserve	0000000000200000
 SizeOfStackCommit	0000000000001000
@@ -264,15 +264,15 @@
  000640f0	00000000 00000000 00000000 00000000 00000000
 
 There is an export table in .edata at 0x25d610000
 
 The Export Tables (interpreted .edata section contents)
 
 Export Flags 			0
-Time/Date stamp 		661c0078
+Time/Date stamp 		662fe1cc
 Major/Minor 			0/0
 Name 				0000000000061126 liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll
 Ordinal Base 			1
 Number in:
 	Export Address Table 		000001b3
 	[Name Pointer/Ordinal] Table	000001b3
 Table Addresses
@@ -120135,17 +120135,17 @@
 	...
 
 Disassembly of section .edata:
 
 000000025d610000 <.edata>:
    25d610000:	add    %al,(%rax)
    25d610002:	add    %al,(%rax)
-   25d610004:	js     25d610006 <.edata+0x6>
-   25d610006:	sbb    $0x66,%al
-   25d610008:	add    %al,(%rax)
+   25d610004:	int3
+   25d610005:	loope  25d610036 <.edata+0x36>
+   25d610007:	data16 add %al,(%rax)
    25d61000a:	add    %al,(%rax)
    25d61000c:	es adc %eax,(%rsi)
    25d61000f:	add    %al,(%rcx)
    25d610011:	add    %al,(%rax)
    25d610013:	add    %dh,-0x4cffffff(%rbx)
    25d610019:	add    %eax,(%rax)
    25d61001b:	add    %ch,(%rax)
```

## seidart/routines/arraybuild.py

```diff
@@ -38,15 +38,15 @@
         self.prjfile = prjfile 
         self.channel = channel
         self.receiver_file = receiver_file
         self.receiver_indices = receiver_indices
         self.single_precision = single_precision
         self.is_complex = is_complex
         self.stream = None
-        self.gain = 100
+        self.gain = None
         self.exaggeration = 0.5
         self.build()
     
     # -------------------------------------------------------------------------
     def build(self):
         """
         Constructs domain and models based on project file and sets up source 
@@ -58,17 +58,19 @@
             Material(),
             Model(),
             Model()
         )
         if self.channel in ['Vx','Vy','Vz']:
             self.is_seismic = True
             self.dt = self.seismic.dt 
+            self.gain = self.seismic.time_steps
         else:
             self.is_seismic = False
             self.dt = self.electromag.dt
+            self.gain = self.time_steps
         
          
         # __, self.receivers_xyz = self.loadxyz()
         self.loadxyz()
         if self.channel == 'Vx' or self.channel == 'Vy' or self.channel == 'Vz':
             if self.domain.dim == '2.0':
                 self.source = np.array(
@@ -99,58 +101,63 @@
         # Load the time series for all receivers
         self.getrcx()
     
     # -------------------------------------------------------------------------
     def loadxyz(self):
         """
         Loads and sorts receiver locations from a file and adjusts them 
-        according to the domain and CPML layer.
+        according to the domain and CPML layer.  If the source_file flag is 
+        True, the source file is loaded instead of the receiver file and saved
+        to the object under source_xyz.
+
+        :param source_file: Flag to indicate if the file is a source file.
+        :type source_file: bool 
+
         """
         xyz = pd.read_csv(self.receiver_file)
         
         # We need to make sure the recievers are ordered correctly and the 
         # absorbing boundary is corrected for
         # First check to see if the inputs are indices or
         cpml = int(self.domain.cpml)
         # Adjust the object fields relative to the cpml. The y-direction will be
         # adjusted when we are 2.5/3D modeling
         self.domain.nx = self.domain.nx + 2*cpml
         self.domain.nz = self.domain.nz + 2*cpml
         if self.domain.dim == 2.5:
             self.domain.ny = self.domain.ny + 2*cpml
         
-        self.receiver_xyz = xyz.to_numpy() 
+        xyz = xyz.to_numpy() 
         
-        if self.receiver_xyz.shape[1] == 1:
-            self.receiver_xyz = self.receiver_xyz.T
+        if xyz.shape[1] == 1:
+            xyz = xyz.T
         
         # We want to make sure the shape of the self.receiver_xyz array is in 
         # the correct shape. We won't be able to differentiate if the array is 
         # in correct shape if it is 3x3
-        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) > 9:
-            self.receiver_xyz = self.receiver_xyz.T
-        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) == 6:
-            self.receiver_xyz = self.receiver_xyz.T
+        if xyz.shape[0] == 3 and np.prod(xyz.shape) > 9:
+            xyz = xyz.T
+        if xyz.shape[0] == 3 and np.prod(xyz.shape) == 6:
+            xyz = xyz.T
         
         # If the receiver file contains values that are relative to the 
         # cartesian space of the domain, we want to change them to the indices
         # of the 
         if not self.receiver_indices:
-            self.receiver_xyz = self.receiver_xyz / \
+            xyz = xyz / \
                 np.array(
                     [
                         float(self.domain.dx), 
                         float(self.domain.dy), 
                         float(self.domain.dz) 
                     ]
                 )
-            self.receiver_xyz.astype(int)
+            xyz.astype(int)
         
-        self.receiver_xyz = self.receiver_xyz + cpml
-        # return(self.domain, self.receiver_xyz)
+        self.receiver_xyz = xyz + cpml
     
     # -------------------------------------------------------------------------
     def getrcx(self):
         """
         Loads the time series data for all receivers and handles complex data
         conditions.
         """
@@ -221,18 +228,18 @@
                     all_files[i], 
                     self.channel, 
                     self.domain, 
                     self.is_complex,
                     single = self.single_precision
                 )
                 if n == 1:
-                    timeseries[:,i] = npdat.real[
+                    timeseries[i] = npdat.real[
                         int(self.receiver_xyz[2]), int(self.receiver_xyz[0])
                     ]
-                    timeseries_complex[:,i] = npdat.imag[
+                    timeseries_complex[i] = npdat.imag[
                         int(self.receiver_xyz[2]), 
                         int(self.receiver_xyz[0])
                     ]
                 else:
                     for j in range(n):
                         # Don't forget x is columns and z is rows
                         timeseries[i,j] = npdat.real[
@@ -324,14 +331,16 @@
             ]
         )
         # Pickle the object and save to file
         with open(filename, 'wb') as file:
             pickle.dump(self, filename)
 
 
+# =============================================================================
+# ============================== Main Function ================================
 def main(
         prjfile: str, 
         receiver_file: str, 
         channel: str, 
         rind: bool, 
         is_complex: bool, 
         single_precision: bool, 
@@ -379,14 +388,16 @@
     if exaggeration:
         array.exaggeration = exaggeration
     if save:
         array.save()
     if plot:
         array.section_plot(plot_complex = plot_complex)
 
+
+
 # =============================================================================
 # ========================== Command Line Arguments ===========================
 # =============================================================================
 if __name__ == "__main__":
     parser = argparse.ArgumentParser(
         description="""This program creates an Array class that can be saved in 
         pickle format. Receiver locations listed in the the specified receiver
```

## seidart/routines/definitions.py

```diff
@@ -563,14 +563,18 @@
 
     The returned string format is 'ID,real1jimag1,real2jimag2,...' where ID is 
     the integer ID, and realN and imagN are the real and imaginary parts of the
     Nth complex number, respectively.
     """
     reals = complex_vector.real[1:]
     comps = complex_vector.imag[1:]
+    
+    reals = [format(x, '.2e') for x in reals]
+    comps = [format(x, '.2e') for x in comps]
+    
     id = complex_vector.real[0].astype(int)
     m = len(reals)
     complex_string_vector = np.zeros([m], dtype = object)
     for ind in range(m):
         complex_string_vector[ind] = str(reals[ind]) + 'j' + str(comps[ind])
     
     return( str(id) + ',' + ','.join(complex_string_vector))
@@ -847,16 +851,16 @@
                     )
                 )
             except:
                 seismic.attenuation_coefficients = np.array(
                     temp[2:5], dtype = float
                 )
                 
-            electromag.fref = float(temp[8])
-            seismic.fref = float(temp[9])
+            # electromag.fref = float(temp[8])
+            seismic.fref = float(temp[5])
 
     f.close()
     return domain, material, seismic, electromag
 
 
 # -----------------------------------------------------------------------------
 # Make sure variables are in the correct type for Fortran
```

## seidart/routines/materials.py

```diff
@@ -293,15 +293,15 @@
     # Adjust the stiffness tensor according to the pressure and temperature 
     # conditions for ice
     for ind in range(0, m):
         
         if material.material[ind] == 'ice1h':
             permittivity = ice_permittivity(
                 material.temp[ind],
-                material.density[ind],
+                material.rho[ind],
                 center_frequency = modelclass.f0
             )
             conductivity = snow_conductivity(
                 permittivity = permittivity, frequency = modelclass.f0
             )
             
         elif material.material[ind] == 'snow':
@@ -899,14 +899,15 @@
     :param frequency: The frequency at which to calculate permittivity, in Hz.
     :type temperature: float
     :type frequency: float
     :return: The complex permittivity value.
     :rtype: float
     """
     # frequency = 1 is equivalent to 1 GHz or 1e9 Hz. The input is in Hz.
+    temperature = temperature + 273 # Convert to Kelvins
     frequency = frequency / 1e9
-    A_val = A_interp(T_given)
-    B_val = B_interp(T_given)
-    C_val = C_interp(T_given)
-    epsilon_val = A_val/f + B_val*(f**C_val)
+    A_val = A_interp(temperature)
+    B_val = B_interp(temperature)
+    C_val = C_interp(temperature)
+    epsilon_val = A_val/frequency + B_val*(frequency**C_val)
     return epsilon_val
```

## seidart/routines/prjrun.py

```diff
@@ -259,15 +259,15 @@
         bcoeff.tofile('bcoef' + direction + '_cpml.dat')
 
 # ================================== SEISMIC ==================================
 def runseismic(
         modelclass: Model, 
         material: Material, 
         domain: Domain, 
-        single_precision: bool
+        single_precision: bool = True
     ) -> None:
     """
     Runs the seismic model using the initialized modelclass, material, and domain.
 
     :param modelclass: The seismic model class instance.
     :param material: The material class instance.
     :param domain: The domain class instance.
@@ -280,16 +280,16 @@
 
     modelclass, domain = prepme(modelclass, domain, complex_tensor = False)
     direction = ['x', 'y', 'z']
     # Compute CPML
     print(direction)
     print('computing cpml')
     for d in direction:
-        cpmlcompute(modelclass, domain, d, seismic = seismic)
-        cpmlcompute(modelclass, domain, d, half = True, seismic = seismic)
+        cpmlcompute(modelclass, domain, d, seismic = True)
+        cpmlcompute(modelclass, domain, d, half = True, seismic = True)
     
     # We need to set a density gradient at air interfaces because high
     # density gradients lead to numerical instability
     rhograd = airsurf(material, domain, 2)
     # Write the coefficient images to a fortran file
     
     # Create the stiffness .dat files
@@ -401,16 +401,15 @@
                 domain.nz + 2*domain.cpml,
                 domain.dx, domain.dz,
                 domain.cpml,
                 modelclass.src,
                 modelclass.time_steps,
                 single_precision
             )
-    else:
-        
+    else:  
         cpmlfdtd.permittivity_write(
                 domain.geometry+1,
                 modelclass.tensor_coefficients.real,
                 domain.cpml,
                 domain.nx, 
                 domain.nz
             )
@@ -527,21 +526,22 @@
         help = """Specify whether to run the seismic (s), or electromagnetic (e), 
         or none (default = n)""",
         default = 'n'
     )
 
     parser.add_argument(
         '-a', '--append',
-        nargs = 1, type = int, required = False, default = [1],
+        action='store_true', required = False,
         help = """Append/recompute the coefficients to the permittivity and
-        stiffness matrices; 1 = yes, 0 = no; default = 1."""
+        stiffness matrices; DEFAULT is True"""
     )
     
     parser.add_argument(
-        '-d', '--double_precision', action='store_false', required = False,
+        '-d', '--double_precision', 
+        action='store_false', required = False,
         help = """Specify double precision output of the simulation. If 
         complex, the outputs are real valued of each of the components of the 
         complex value. The default is True."""
     )
     
     parser.add_argument(
         '-c', '--use_complex_equations', action = 'store_true', required = False,
@@ -563,15 +563,15 @@
     #     default is False."""
     # )
 
     # Get the arguments
     args = parser.parse_args()
     prjfile = ''.join(args.prjfile)
     model_type = ''.join(args.model)
-    append_to_prjfile = args.append[0] == 1
+    append_to_prjfile = args.append
     pwd = os.path.dirname(prjfile)
     double_precision = args.double_precision
     use_complex_equations = args.use_complex_equations
      
     # attenuation = args.attenuation
     #
     main(
```

## seidart/simulations/common_offset.py

```diff
@@ -1,55 +1,206 @@
-import numpy 
+import numpy as np
+import pandas as pd
 from seidart.routines.definitions import *
+from seidart.routines import prjrun, sourcefunction
+from seidart.routines.definitions import Domain, Material, Model
 from seidart.routines.arraybuild import Array
 from glob2 import glob 
+import os
 
-# Constants
-# prjfile = 'test_co.prj' 
-# rcxfile = 'receivers.xyz'
-# srcfile = 'sources.xyz'
-
-# # Initiate the model and domain objects
-# dom, mat, seis, em = prjrun.domain_initialization(prjfile)
-
-# !!!! Meters or indices?
-# offsets = [3, 0, 0]
-# rgb = np.array([0,0,0])
-# xyz = rcxgen(rgb, dom, mat, filename = rcxfile)
-# # In this case, we want every 4 of the output xyz because when converting from
-# # PDF to png we doubled the points.
-# xyz = xyz[::4,:]
-# src = xyz + offsets
-
-# prjrun.status_check(
-#     seis, 
-#     mat,
-#     dom,
-#     prjfile, 
-#     seismic=True, 
-#     appendbool = True
-# )
-
-# prjrun.status_check(
-#     em, 
-#     mat,
-#     dom,
-#     prjfile, 
-#     seismic=False, 
-#     appendbool = True
-# )
-
-
-# # Create the source functions
-# st, fx, fy, fz, srcfn = sourcefunction(seis, 1e7, 'gaus1', 's')
-# # et, fx, fy, fz, srcfn = sourcefunction(em, 1e7, 'gaus1', 'e')
-
-# chan = 'Vz'
-# n = src.shape[0]
-# timeseries = np.zeros([int(seis.time_steps), n])
-# for ind in range(n):
-#     seis.x = src[ind, 0]
-#     seis.y = src[ind, 1]
-#     seis.z = src[ind, 2]
-#     prjrun.run(seis, mat, dom, seismic=True)
-#     source = np.array([int(seis.x), int(seis.z)])
-#     timeseries[:,ind] = getrcx(chan, xyz[ind,:], source, dom)
+# =============================================================================
+class CommonOffset(Array):
+    """
+    Utilize the Array class to build a common offset image from a .prj file and 
+    a source location file. If offsets are not provided then a receiver file 
+    must be provided that coincides with the source file.
+
+    The 
+    """
+    def __init__(
+            self, source_file: str, 
+            channel: str,
+            prjfile: str, 
+            receiver_file: str,
+            receiver_indices: bool = False, 
+            single_precision: bool = True,
+            is_complex: bool = False
+        ): #*args, **kwargs) -> None:
+        """
+        Initialize the CommonOffset object. A receiver file must be provided 
+        that coincides with the source file.
+
+        :param source_file: The source file that contains the source locations
+        :type source_file: str
+        :param args: Additional positional arguments inherited from the Array 
+            class.
+        :type args: tuple
+        :param kwargs: Additional keyword arguments inherited from the Array 
+            class.
+        :type kwargs: dict
+
+        """
+        # super().__init__(source_file, *args, **kwargs) 
+        self.source_file = source_file
+        self.prjfile = prjfile
+        self.channel = channel
+        self.receiver_file = receiver_file
+        self.receiver_indices = receiver_indices
+        self.single_precision = single_precision    
+        self.is_complex = is_complex
+        self.gain = 100
+        self.exaggeration = 0.5
+        self.build()
+
+    def build(self) -> None:
+        """
+        Constructs domain and models based on project file and sets up source 
+        and receiver configurations.
+        """
+        self.domain, self.material, self.seismic, self.electromag = loadproject(
+            self.prjfile,
+            Domain(), 
+            Material(),
+            Model(),
+            Model()
+        )
+        if self.channel in ['Vx','Vy','Vz']:
+            self.is_seismic = True
+            self.dt = self.seismic.dt 
+        else:
+            self.is_seismic = False
+            self.dt = self.electromag.dt
+        
+         
+        # Load the source and receiver locations
+        self.source_receiver_xyz()
+
+        # Copy the receiver_xyz to the variable receiver_xyz_all because we 
+        # will modify the receiver_xyz variable
+        self.receiver_xyz_all = self.receiver_xyz.copy()
+        self.receiver_xyz = np.empty((0,3))
+
+    def source_receiver_xyz(self):
+        """
+        Loads and sorts receiver and source locations from a file and adjusts them 
+        according to the domain and CPML layer. 
+        """
+        
+        self.source_xyz = pd.read_csv(self.source_file)
+        self.receiver_xyz = pd.read_csv(self.receiver_file)
+        
+        # We need to make sure the receivers are ordered correctly and the 
+        # absorbing boundary is corrected for
+        # First check to see if the inputs are indices or
+        cpml = int(self.domain.cpml)
+        
+        
+        self.source_xyz = self.source_xyz.to_numpy() 
+        self.receiver_xyz = self.receiver_xyz.to_numpy()
+        if self.receiver_xyz.shape[1] == 1:
+            self.receiver_xyz = self.receiver_xyz.T
+        
+        # We want to make sure the shape of the self.receiver_xyz array is in 
+        # the correct shape. We won't be able to differentiate if the array is 
+        # in correct shape if it is 3x3
+        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) > 9:
+            self.receiver_xyz = self.receiver_xyz.T
+        if self.receiver_xyz.shape[0] == 3 and np.prod(self.receiver_xyz.shape) == 6:
+            self.receiver_xyz = self.receiver_xyz.T
+        
+        # If the receiver file contains values that are relative to the 
+        # cartesian space of the domain, we want to change them to the indices
+        # of the 
+        if not self.receiver_indices:
+            self.receiver_xyz = self.receiver_xyz / \
+                np.array(
+                    [
+                        float(self.domain.dx), 
+                        float(self.domain.dy), 
+                        float(self.domain.dz) 
+                    ]
+                )
+            self.receiver_xyz.astype(int)
+        
+        self.source_xyz = self.source_xyz
+        self.receiver_xyz = self.receiver_xyz + cpml
+    
+    def co_run(self, seismic: bool = True) -> None:
+        """
+        Run the electromagnetic or seismic model and extract the receiver 
+        time series
+
+        :param seismic: If True, run the seismic model. If False, run the 
+            electromagnetic model.
+        :type seismic: bool
+
+        """
+        self.timevec, self.fx, self.fy, self.fz, self.srcfn = sourcefunction(
+            self.electromag, 1e7, 'gaus1', 'e'
+        )
+        n = len(self.source_xyz)
+        self.co_image = np.zeros([len(self.timevec), n])
+        self.co_image_complex = self.co_image.copy()
+
+        # Loop through the source locations
+        for i in range(n):
+            self.receiver_xyz = self.receiver_xyz_all[i,:]
+            self.source = self.source_xyz[i,:]
+
+            print(f'Running shot gather for source location {self.source}')
+            # Run the seismic or electromagnetic model
+            if seismic:
+                self.seismic.x = self.source[0]
+                self.seismic.y = self.source[1]
+                self.seismic.z = self.source[2]
+                prjrun.runseismic(self.seismic, self.material, self.domain)
+            else:
+                self.electromag.x = self.source[0]
+                self.electromag.y = self.source[1]
+                self.electromag.z = self.source[2]
+                prjrun.runelectromag(
+                    self.electromag, 
+                    self.material, 
+                    self.domain, 
+                    use_complex_equations = self.is_complex
+                )
+            
+            # Extract the receiver time series
+            self.domain.nx = self.domain.nx + 2 * int(self.domain.cpml)
+            self.domain.nz = self.domain.nz + 2 * int(self.domain.cpml)
+            if self.domain.dim == 2.5:
+                self.domain.ny = self.domain.ny + 2 * int(self.domain.cpml)
+            
+            self.getrcx() 
+            # Put a bandaid on the domain values 
+            self.domain.nx = self.domain.nx - 2 * int(self.domain.cpml)
+            self.domain.nz = self.domain.nz - 2 * int(self.domain.cpml)
+            if self.domain.dim == 2.5:
+                self.domain.ny = self.domain.ny - 2 * int(self.domain.cpml)
+            
+            # Remove all of the files 
+            for file in glob('E*.0*.dat'):
+                try:
+                    os.remove(file) 
+                except OSError as e:
+                    print(f"Error removing file: {e.strerror}")
+                    
+
+            self.co_image[:,i] = self.timeseries
+            # If the desired model is complex, extract the complex time series
+            if self.is_complex:
+                self.co_image_complex[:,i] = self.timeseries_complex
+            
+            # Overwrite the self.timeseries and self.timeseries_complex
+            # variables wth the self.co_image variable
+            self.timeseries = self.co_image
+            self.timeseries_complex = self.co_image_complex
+
+    # def receiver_timeseries(self):
+    #     if self.domain.dim == 2.5:
+    #         all_files = glob(
+    #             self.channel + '*.' + '.'.join(src_ind.astype(str)) + '.dat'
+    #         )
+    #     else: 
+    #         all_files = glob(
+    #             self.channel + '*.' + '.'.join(src_ind[np.array([0,2])].astype(str)) + '..dat'
+    #         )
```

## Comparing `seidart-0.1.0.dist-info/LICENSE.txt` & `seidart-0.1.1.dist-info/LICENSE.txt`

 * *Files identical despite different names*

## Comparing `seidart-0.1.0.dist-info/METADATA` & `seidart-0.1.1.dist-info/METADATA`

 * *Files 0% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: seidart
-Version: 0.1.0
+Version: 0.1.1
 Summary: seidarT is a 2 and 2.5d seismic and electromagnetic modeling suite.
 Author-email: Steven Bernsen <spbernsen@alaska.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
 Maintainer-email: Steven Bernsen <spbernsen@alaska.edu>, Christopher Gerbi <christopher.gerbi@maine.edu>
 License: GNU GENERAL PUBLIC LICENSE
                                Version 3, 29 June 2007
         
          Copyright (C) 2007 Free Software Foundation, Inc. <https://fsf.org/>
```

## Comparing `seidart-0.1.0.dist-info/RECORD` & `seidart-0.1.1.dist-info/RECORD`

 * *Files 9% similar despite different names*

```diff
@@ -1,27 +1,27 @@
 seidart/__init__.py,sha256=PVrfk7vRKkpJJHJU_a-ItErANR2O9hk5oFHOSiOL-Ig,127
-seidart/.libs/libcpmlfdtd.AP6PGGFW2QZKYFCDZKTSOH6GOIU3KKZG.gfortran-win_amd64.dll,sha256=9-h04Eu9xrRqvBcW8UEK_98TVEw-mCc-DR_e8Y8BAlk,1043789
-seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll,sha256=R5WiGvMsyLR8NCnJ9isE5qxr4mQws3L_eNAHLl5gv6k,713500
+seidart/.libs/libcpmlfdtd.HHM64BD6ITWEAQBB4CKPKFCVIIT6G6AX.gfortran-win_amd64.dll,sha256=ztelWBRmp0ivsXEVsqYQIgqVNEGPkQmXL7vpadg9ZV4,1455789
+seidart/.libs/liborientsy.46ZIMVLJE5LCA4G2UOFZXRF3CW2ULZMI.gfortran-win_amd64.dll,sha256=VzKPZr3h1ZZ6PhMN7yhGfkDtdDdAufY6F47QpVrp0Os,713500
 seidart/fortran/__init__.py,sha256=4nOBVLNyIYohjXzZup9l2bSWdxEWZ1kckQ5ct7VKcJ4,17
-seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd,sha256=gxl-0S0-ow4l4IQvylcscFVIbuYV5FdPEjEcEwcy4SE,62464
-seidart/fortran/orientsynth.cp311-win_amd64.pyd,sha256=MAIyuSUYkh4Cng5EkV83brd11Jxmr75zX2zrIadGUoA,35840
+seidart/fortran/cpmlfdtd.cp311-win_amd64.pyd,sha256=xn1TBXgmgkhGBwRr8WfO9XF_97GrFH9wwyONvgRf1V8,73728
+seidart/fortran/orientsynth.cp311-win_amd64.pyd,sha256=aWT9k-Nn0MOGrL-T1LlCse92nNsJHGn0stEJQcDdSrw,35840
 seidart/routines/__init__.py,sha256=02YBzrjiGHhmBrXzGNuL-XNLPYP5CNaKcT-Ndy-f6R0,232
-seidart/routines/arraybuild.py,sha256=w_DbxAuPFsMK_dC87AKFcvOzAHDM9c6X5tyGBSPCUd4,17771
-seidart/routines/definitions.py,sha256=4HinCSjBiUToE5PQnkRPTKM7qdfVvuNEYOETDeX6B0g,51325
-seidart/routines/materials.py,sha256=IA5R2QnztjoW4X0Dbrx_R8VoOf2MJbUvlCcYaqokkUw,35180
+seidart/routines/arraybuild.py,sha256=3G-xqcOwBWlGQNBYTkvb9UX5zliCuq-VK0wkDweVcR4,18014
+seidart/routines/definitions.py,sha256=kmX_BT4xwE9KkurEs_XoCOs9K8b988z7c4bw-lisflc,51433
+seidart/routines/materials.py,sha256=OuHVjXLov2fDeCYZHbpJ-JpQsJt4yUC6DN2gi_2cpNg,35262
 seidart/routines/orientation_tensor.py,sha256=uqiunYoDxvVC2kLzxKgXgHq9wZONf8iFS_SGKgchZ1U,3939
 seidart/routines/prjbuild.py,sha256=kozfXfUmdXtL5q6HxKWJHN4OfdhXhyps44X5Z1uaVRo,9671
-seidart/routines/prjrun.py,sha256=lYF6QuyWzEUxh5B4qwTVWbEX-pIQobceH5i2Vf-Q6vU,21632
+seidart/routines/prjrun.py,sha256=HDshvBBMGAHQJvWszwn1hOHW-b5MW2n0AC73hK768sY,21596
 seidart/routines/sourcefunction.py,sha256=zg4Q-4f-PEbuk2MZ6G6L78nb1EZivl5nX5gmIP56CDA,9871
 seidart/simulations/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-seidart/simulations/common_offset.py,sha256=M1aghxw82nGlQTeuO1WuQIwAh1PRUC0D2c91smylNK4,1430
+seidart/simulations/common_offset.py,sha256=kfS-_SjBMfbJToqrHxUH21kk2bONytmoj_BmuAYTZ_Q,8201
 seidart/visualization/__init__.py,sha256=uwwvcjJJUICSIcY8M3laZwDFwJTKty0mOBilXpkNxYk,46
 seidart/visualization/im2anim.py,sha256=UA3kq8siu-on4AmwzALi04JOKq3RtNG9Q_kleeHHNOU,7092
 seidart/visualization/imgen.py,sha256=Z61xz4lRpquQ_AEUFhuRyUVPP5AnP-OFwVr3tcKaAkU,13729
 seidart/visualization/implot.py,sha256=_HTv39e0qcbtSp2P1kxvLz6yMTVeu9Ep3alTboFfdb0,1291
 seidart/visualization/slice25d.py,sha256=RDErIsK5u7Ie6O0dtyuEaRzmDchIXYx1nv0XgiRXpQo,5280
 seidart/visualization/vtkbuild.py,sha256=Z3oyrNDEJxuo-9hrSNxlLQam_PunqQVXV2bCkd0n2mQ,4088
-seidart-0.1.0.dist-info/LICENSE.txt,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
-seidart-0.1.0.dist-info/METADATA,sha256=2FQRH5Z33j8K4pV8dhNpX_kEmUrmYvAOUS2H0BFFjGA,48376
-seidart-0.1.0.dist-info/WHEEL,sha256=nSybvzWlmdJnHiUQSY-d7V1ycwEVUTqXiTvr2eshg44,102
-seidart-0.1.0.dist-info/top_level.txt,sha256=M8E1K6tlpjukvjp2DWa9jKXRnBorH-dxJ7QQpTb7TQI,8
-seidart-0.1.0.dist-info/RECORD,,
+seidart-0.1.1.dist-info/LICENSE.txt,sha256=IwGE9guuL-ryRPEKi6wFPI_zOhg7zDZbTYuHbSt_SAk,35823
+seidart-0.1.1.dist-info/METADATA,sha256=a4YUnEhhT_QJgGwGJYKcxYnTJtQOmRfR-4Y8dTZbylc,48376
+seidart-0.1.1.dist-info/WHEEL,sha256=nSybvzWlmdJnHiUQSY-d7V1ycwEVUTqXiTvr2eshg44,102
+seidart-0.1.1.dist-info/top_level.txt,sha256=M8E1K6tlpjukvjp2DWa9jKXRnBorH-dxJ7QQpTb7TQI,8
+seidart-0.1.1.dist-info/RECORD,,
```

