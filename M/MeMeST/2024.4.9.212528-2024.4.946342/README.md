# Comparing `tmp/MeMeST-2024.4.9.212528-py3-none-any.whl.zip` & `tmp/MeMeST-2024.4.946342-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,18 @@
-Zip file size: 34940 bytes, number of entries: 20
--rwxrwxr-x  2.0 unx    35149 b- defN 24-Apr-07 13:17 MeMeST-2024.4.9.212528.data/data/LICENSE
--rw-rw-r--  2.0 unx       76 b- defN 24-Apr-08 13:40 git_tools/__init__.py
--rw-rw-r--  2.0 unx     1177 b- defN 24-Apr-09 13:05 git_tools/base_dtypes.py
--rw-rw-r--  2.0 unx     4938 b- defN 24-Apr-09 13:11 git_tools/git_api.py
--rw-rw-r--  2.0 unx      143 b- defN 24-Apr-08 05:47 git_tools/rep_task.py
--rw-rw-r--  2.0 unx        0 b- defN 24-Apr-07 15:42 mest/__init__.py
--rw-rw-r--  2.0 unx     4193 b- defN 24-Apr-08 03:33 mest/config.py
--rw-rw-r--  2.0 unx     1756 b- defN 24-Apr-09 13:19 mest/main.py
--rw-rw-r--  2.0 unx     2252 b- defN 24-Apr-09 13:19 mest/rep_mana.py
--rw-rw-r--  2.0 unx      569 b- defN 24-Apr-09 08:40 mest/test_git.py
--rw-rw-r--  2.0 unx       76 b- defN 24-Apr-08 13:40 mest/git_tools/__init__.py
--rw-rw-r--  2.0 unx     1177 b- defN 24-Apr-09 08:29 mest/git_tools/base_dtypes.py
--rw-rw-r--  2.0 unx     4552 b- defN 24-Apr-09 08:19 mest/git_tools/git_api.py
--rw-rw-r--  2.0 unx      143 b- defN 24-Apr-08 05:47 mest/git_tools/rep_task.py
--rwxrwxr-x  2.0 unx    35149 b- defN 24-Apr-09 13:25 MeMeST-2024.4.9.212528.dist-info/LICENSE
--rw-rw-r--  2.0 unx      919 b- defN 24-Apr-09 13:25 MeMeST-2024.4.9.212528.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-Apr-09 13:25 MeMeST-2024.4.9.212528.dist-info/WHEEL
--rw-rw-r--  2.0 unx       42 b- defN 24-Apr-09 13:25 MeMeST-2024.4.9.212528.dist-info/entry_points.txt
--rw-rw-r--  2.0 unx       15 b- defN 24-Apr-09 13:25 MeMeST-2024.4.9.212528.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1630 b- defN 24-Apr-09 13:25 MeMeST-2024.4.9.212528.dist-info/RECORD
-20 files, 94048 bytes uncompressed, 32280 bytes compressed:  65.7%
+Zip file size: 33554 bytes, number of entries: 16
+-rwxrwxr-x  2.0 unx    35149 b- defN 24-Apr-10 04:45 MeMeST-2024.4.946342.data/data/LICENSE
+-rw-rw-r--  2.0 unx       76 b- defN 24-Apr-10 04:45 git_tools/__init__.py
+-rw-rw-r--  2.0 unx     1139 b- defN 24-Apr-18 09:30 git_tools/base_dtypes.py
+-rw-rw-r--  2.0 unx     8708 b- defN 24-Apr-29 10:47 git_tools/git_api.py
+-rw-rw-r--  2.0 unx      143 b- defN 24-Apr-10 04:45 git_tools/rep_task.py
+-rw-rw-r--  2.0 unx        0 b- defN 24-Apr-10 04:45 mest/__init__.py
+-rw-rw-r--  2.0 unx     4518 b- defN 24-Apr-29 10:15 mest/config.py
+-rw-rw-r--  2.0 unx     3172 b- defN 24-Apr-29 10:57 mest/main.py
+-rw-rw-r--  2.0 unx     2526 b- defN 24-Apr-29 10:57 mest/rep_mana.py
+-rw-rw-r--  2.0 unx      569 b- defN 24-Apr-10 04:45 mest/test_git.py
+-rwxrwxr-x  2.0 unx    35149 b- defN 24-Apr-29 10:58 MeMeST-2024.4.946342.dist-info/LICENSE
+-rw-rw-r--  2.0 unx     1726 b- defN 24-Apr-29 10:58 MeMeST-2024.4.946342.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-Apr-29 10:58 MeMeST-2024.4.946342.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       42 b- defN 24-Apr-29 10:58 MeMeST-2024.4.946342.dist-info/entry_points.txt
+-rw-rw-r--  2.0 unx       15 b- defN 24-Apr-29 10:58 MeMeST-2024.4.946342.dist-info/top_level.txt
+?rw-rw-r--  2.0 unx     1286 b- defN 24-Apr-29 10:58 MeMeST-2024.4.946342.dist-info/RECORD
+16 files, 94310 bytes uncompressed, 31438 bytes compressed:  66.7%
```

## zipnote {}

```diff
@@ -1,8 +1,8 @@
-Filename: MeMeST-2024.4.9.212528.data/data/LICENSE
+Filename: MeMeST-2024.4.946342.data/data/LICENSE
 Comment: 
 
 Filename: git_tools/__init__.py
 Comment: 
 
 Filename: git_tools/base_dtypes.py
 Comment: 
@@ -24,38 +24,26 @@
 
 Filename: mest/rep_mana.py
 Comment: 
 
 Filename: mest/test_git.py
 Comment: 
 
-Filename: mest/git_tools/__init__.py
+Filename: MeMeST-2024.4.946342.dist-info/LICENSE
 Comment: 
 
-Filename: mest/git_tools/base_dtypes.py
+Filename: MeMeST-2024.4.946342.dist-info/METADATA
 Comment: 
 
-Filename: mest/git_tools/git_api.py
+Filename: MeMeST-2024.4.946342.dist-info/WHEEL
 Comment: 
 
-Filename: mest/git_tools/rep_task.py
+Filename: MeMeST-2024.4.946342.dist-info/entry_points.txt
 Comment: 
 
-Filename: MeMeST-2024.4.9.212528.dist-info/LICENSE
+Filename: MeMeST-2024.4.946342.dist-info/top_level.txt
 Comment: 
 
-Filename: MeMeST-2024.4.9.212528.dist-info/METADATA
-Comment: 
-
-Filename: MeMeST-2024.4.9.212528.dist-info/WHEEL
-Comment: 
-
-Filename: MeMeST-2024.4.9.212528.dist-info/entry_points.txt
-Comment: 
-
-Filename: MeMeST-2024.4.9.212528.dist-info/top_level.txt
-Comment: 
-
-Filename: MeMeST-2024.4.9.212528.dist-info/RECORD
+Filename: MeMeST-2024.4.946342.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## git_tools/base_dtypes.py

```diff
@@ -1,8 +1,16 @@
 import time
+import hashlib
+
+
+def unique_id(input_str):
+    hash_object = hashlib.md5(input_str.encode())
+    hex_dig = hash_object.hexdigest()
+    unique_id = hex_dig[:12]
+    return unique_id
 
 
 class RepData:
     update_time = 0
     timeout = 600
     alias = ""
     address = None
@@ -23,20 +31,15 @@
         @address git@github.com:xxmawhu/example.git
         """
         self.update_time = time.time()
         self.address = address
         self.work_dir = work_dir
         self.key_file = key_file
         self.timeout = timeout or 600
-        if ".com" in address:
-            usr = "_".join(address.split(":")[-1].split("/")[:]).replace(".git", "")
-            host = address.split("@")[-1].split(".")[0]
-            self.alias = f"{host}_{usr}"
-        else:
-            self.alias = "local"
+        self.alias = unique_id(address)
 
 
 class RepCacheData:
     local: RepData = None
     remote_rep_list = []
 
     def __init__(self, local, remote=[]):
```

## git_tools/git_api.py

```diff
@@ -1,130 +1,281 @@
 import os
 import subprocess
 from loguru import logger
 from .base_dtypes import RepData, RepCacheData
 
+ENV = os.environ.copy()
+ENV["LD_LIBRARY_PATH"] = ""
+ENV["PATH"] = "/usr/bin:/bin:/usr/local/bin"
+if "OPENSSL_DIR" in ENV:
+    del ENV["OPENSSL_DIR"]
+
 
 def mkdir(path):
     if not os.path.exists(path):
         os.makedirs(path)
 
 
 def get_all_remotes(work_dir: str):
-    cmd = ['git', 'remote', '-v']
-    result = subprocess.check_output(cmd, cwd=work_dir, text=True).splitlines()
-    remotes = [line.split('\t')[0] for line in result]
+    cmd = ["git", "remote", "-v"]
+    result = subprocess.check_output(
+        cmd,
+        cwd=work_dir,
+        text=True,
+        env=ENV,
+    ).splitlines()
+    remotes = [line.split("\t")[0] for line in result]
     return list(set(remotes))
 
 
-def ensure_bare_repository(local_rep):
-    address = local_rep.address
-    if os.path.isdir(address) and os.path.isfile(os.path.join(address, 'config')):
+def get_local_branch_list(work_dir):
+    git_command = ["git", "branch"]
+    output = subprocess.check_output(git_command, text=True, cwd=work_dir)
+    branch_list = [line.split(" ")[-1] for line in output.splitlines()]
+    return branch_list
+
+
+def good_rep_data(rep_data):
+    return rep_data.alias and rep_data.address and rep_data.work_dir
+
+
+def ensure_bare_repository(rep_data):
+    if not good_rep_data(rep_data):
+        return
+    address = rep_data.address
+    if os.path.isdir(address) and os.path.isfile(os.path.join(address, "config")):
         # logger.info("Address '{}' is already a bare Git repository.", local_rep.address)
         pass
     else:
-        cmd = ['git', 'init', '--bare', local_rep.address]
+        cmd = ["git", "init", "--bare", rep_data.address]
         subprocess.run(cmd, check=True)
+        logger.info("init bare repository:{}", rep_data.address)
+
+
+def is_git_rep(work_dir):
+    if not os.path.exists(work_dir):
+        return False
+    cmd = ["git", "status"]
+    result = subprocess.run(
+        cmd,
+        env=ENV,
+        cwd=work_dir,
+        stdout=subprocess.DEVNULL,
+        stderr=subprocess.DEVNULL,
+        check=False,
+    )
+    if result.returncode == 0:
+        return True
+    logger.info("{} is not a git repository", work_dir)
+    return False
 
 
 def init_rep(rep_data: RepData):
+    if not good_rep_data(rep_data):
+        return
     mkdir(rep_data.work_dir)
-    logger.info("[{}] init_rep", rep_data.alias)
-    git_dir = os.path.join(rep_data.work_dir, '.git')
+    # logger.info("{}: init_rep", rep_data.address)
+    git_dir = os.path.join(rep_data.work_dir, ".git")
     is_git_repo = os.path.isdir(git_dir)
     if not is_git_repo:
         logger.info("Initializing {}", rep_data.work_dir)
-        subprocess.run(['git', 'init'], cwd=rep_data.work_dir, check=False, Text=True)
+        subprocess.run(["git", "init"], cwd=rep_data.work_dir, check=False, text=True)
         logger.info("Repository {} initialized.", rep_data.work_dir)
     # 添加远程仓库
     if rep_data.alias == "":
         logger.error("[{}] alias is null", rep_data.address)
         return
     if rep_data.address == "":
         logger.error("address is null", rep_data.address)
         return
     if rep_data.alias == "local":
         ensure_bare_repository(rep_data)
     # 增加remote 仓库
     all_remotes = get_all_remotes(rep_data.work_dir)
     if rep_data.alias not in all_remotes:
-        logger.info("add remote {}", rep_data.alias)
-        cmd = ['git', 'remote', 'add', rep_data.alias, rep_data.address]
+        logger.info("{} as remote", rep_data.address)
+        cmd = ["git", "remote", "add", rep_data.alias, rep_data.address]
         subprocess.run(cmd, cwd=rep_data.work_dir, check=True)
 
 
+@logger.catch
 def fetch(rep_data: RepData):
+    if not good_rep_data(rep_data):
+        return
+    logger.info("fetch {}", rep_data.address)
+    cmd = []
     if rep_data.key_file:
-        key_file = rep_data.key_file
-        cmd = ['ssh-agent', 'sh', '-c', f'GIT_SSH_COMMAND="ssh -i {key_file}" git fetch {rep_data.alias}']
-    else:
-        cmd = ['git', 'fetch', rep_data.alias]
-    try:
-        result = subprocess.run(cmd, cwd=rep_data.work_dir, check=True, stdout=subprocess.DEVNULL)
-    except Exception as e:
-        logger.error("{} {}", e, result)
+        git_ssh_command = f'ssh -i "{rep_data.key_file}"'
+        cmd.append(git_ssh_command)
+    cmd += ["git", "fetch", rep_data.alias]
+    result = subprocess.run(
+        cmd,
+        env=ENV,
+        cwd=rep_data.work_dir,
+        stdout=subprocess.DEVNULL,
+        stderr=subprocess.PIPE,
+        check=False,
+    )
+    if result.returncode != 0:
+        logger.error(
+            "fetch {} fail, code:{} reason:{}",
+            rep_data.address,
+            result.returncode,
+            result.stderr.decode("utf-8"),
+        )
+        return
     update_branch_list(rep_data)
 
 
-def get_remote_branches(work_dir, alias):
-    """
-    Given a local working directory (work_dir) and a remote alias (alias),
-    return a list of all branches associated with the specified remote.
-
-    Args:
-        work_dir (str): Path to the local Git repository.
-        alias (str): Name of the remote to fetch branches from.
-
-    Returns:
-        list[str]: List containing the names of all branches from the specified remote.
-    """
-
-    # Execute the 'git branch -r' command to list all remote branches
-
-    # Run the command and capture its output
-
-    # Filter the output to keep only the branches belonging to the given remote alias
-
-    # Extract the branch names by removing the remote prefix (e.g., "alias/")
-
-
 def update_branch_list(rep_data: RepData):
     work_dir = rep_data.work_dir
     git_command = ["git", "branch", "-r"]
     output = subprocess.check_output(git_command, text=True, cwd=work_dir)
     alias = rep_data.alias
-    remote_branches = [line.strip() for line in output.splitlines() if line.strip().startswith(alias)]
-    rep_data.branch_list = [branch_name[len(alias) + 1:] for branch_name in remote_branches]
-    logger.info("remote_branches {}", rep_data.branch_list)
-
-
-def get_local_branch_list(work_dir):
-    git_command = ["git", "branch"]
-    output = subprocess.check_output(git_command, text=True, cwd=work_dir)
-    branch_list = [line.split(" ")[-1] for line in output.splitlines()]
-    return branch_list
+    remote_branches = [
+        line.strip() for line in output.splitlines() if line.strip().startswith(alias)
+    ]
+    rep_data.branch_list = [
+        branch_name[len(alias) + 1 :] for branch_name in remote_branches
+    ]
+    # logger.info("remote_branches {}", rep_data.branch_list)
 
 
+@logger.catch
 def push(rep_data: RepData):
+    if not good_rep_data(rep_data):
+        return
     local_branch_list = get_local_branch_list(rep_data.work_dir)
-    logger.info("[{}] local_branch_list:{}", rep_data.alias, local_branch_list)
+    logger.info("push to {}", rep_data.address)
     work_dir = rep_data.work_dir
     for branch in local_branch_list:
-        checkout_command = ['git', 'checkout', branch]
-        subprocess.run(checkout_command, cwd=work_dir, check=True, stdout=subprocess.DEVNULL)
-        push_command = ['git', 'push', rep_data.alias, branch]
-        logger.info("{}", " ".join(push_command))
-        try:
-            result = subprocess.run(push_command, cwd=work_dir, check=True, stdout=subprocess.DEVNULL)
-        except Exception as e:
-            logger.error("{}, {}", result, e)
+        checkout_command = ["git", "checkout", branch]
+        logger.info("run {}", checkout_command)
+        result = subprocess.run(
+            checkout_command,
+            cwd=work_dir,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.PIPE,
+            check=False,
+        )
+        if result.returncode != 0:
+            logger.error(
+                "fail, code:{} reason:{}",
+                result.returncode,
+                result.stderr.decode("utf-8"),
+            )
+            continue
+
+        push_command = []
+        pull_command = []
+        if rep_data.key_file:
+            git_ssh_command = f'ssh -i "{rep_data.key_file}"'
+            push_command.append(git_ssh_command)
+            pull_command.append(git_ssh_command)
+
+        pull_command += ["git", "pull", rep_data.alias, branch]
+        logger.info("run {}", pull_command)
+        result = subprocess.run(
+            pull_command,
+            cwd=work_dir,
+            env=ENV,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.PIPE,
+            check=False,
+        )
+        if result.returncode != 0:
+            logger.error(
+                "pull to {} fail, code:{} reason:{}",
+                rep_data.address,
+                result.returncode,
+                result.stderr.decode("utf-8"),
+            )
+
+        push_command += ["git", "push", rep_data.alias, branch]
+        logger.info("run {}", push_command)
+        result = subprocess.run(
+            push_command,
+            cwd=work_dir,
+            env=ENV,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.PIPE,
+            check=False,
+        )
+        if result.returncode != 0:
+            logger.error(
+                "push to {} fail, code:{} reason:{}",
+                rep_data.address,
+                result.returncode,
+                result.stderr.decode("utf-8"),
+            )
 
 
 def merge_remote_branches(rep_data):
+    if not good_rep_data(rep_data):
+        return
     work_dir = rep_data.work_dir
     branch_list = rep_data.branch_list
     alias = rep_data.alias
     for branch in branch_list:
-        checkout_command = ['git', 'checkout', branch]
-        merge_command = ['git', 'merge', f'{alias}/{branch}']
-        subprocess.run(checkout_command, cwd=work_dir, check=True, stdout=subprocess.DEVNULL)
-        subprocess.run(merge_command, cwd=work_dir, check=True, stdout=subprocess.DEVNULL)
+        checkout_command = ["git", "checkout", branch]
+        subprocess.run(
+            checkout_command,
+            cwd=work_dir,
+            env=ENV,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.PIPE,
+            check=False,
+        )
+        subprocess.run(
+            ["git", "merge", "--no-commit" f"{alias}/{branch}"],
+            cwd=work_dir,
+            check=False,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
+        )
+        subprocess.run(
+            ["git", "add", "."],
+            cwd=work_dir,
+            check=False,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
+        )
+        subprocess.run(
+            ["git", "commit" "-m", "Force merged with conflicts"],
+            cwd=work_dir,
+            check=False,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.DEVNULL,
+        )
+
+
+def check_remotes(rep_cache_data: RepCacheData):
+    if rep_cache_data.local is None:
+        return
+    work_dir = rep_cache_data.local.work_dir
+    if not os.path.exists(work_dir):
+        logger.error("{} not exists", work_dir)
+    if not is_git_rep(work_dir):
+        return
+    remote_list = rep_cache_data.remote_rep_list
+    alias_list = [data.alias for data in remote_list]
+    alias_list += ["local"]
+    currency_remotes = get_all_remotes(work_dir)
+    remotes_to_removed = [i for i in currency_remotes if i not in alias_list]
+    for remote in remotes_to_removed:
+        git_command = ["git", "remote", "remove", remote]
+        result = subprocess.run(
+            git_command,
+            cwd=work_dir,
+            env=ENV,
+            stdout=subprocess.DEVNULL,
+            stderr=subprocess.PIPE,
+            check=False,
+        )
+        if result.returncode == 0:
+            logger.info("git remote remove {} success", remote)
+        else:
+            logger.error(
+                "git remote remove {} fail! reason:{}",
+                remote,
+                result.stderr.decode("utf-8"),
+            )
```

## mest/config.py

```diff
@@ -1,76 +1,84 @@
 import time
 import hashlib
 import configparser
 
+from loguru import logger
 
-def calculate_file_hash(file_path, algorithm='md5'):
+
+def calculate_file_hash(file_path, algorithm="md5"):
     # 创建哈希对象
     hasher = hashlib.new(algorithm)
 
     # 打开文件并逐块读取数据进行哈希计算
-    with open(file_path, 'rb') as file:
-        for chunk in iter(lambda: file.read(4096), b''):
+    with open(file_path, "rb") as file:
+        for chunk in iter(lambda: file.read(4096), b""):
             hasher.update(chunk)
 
     # 返回哈希值的十六进制表示
     return hasher.hexdigest()
 
 
 class Config:
 
-    def __init__(self, config_file: str = 'config.ini') -> None:
+    def __init__(self, config_file: str = "config.ini") -> None:
         self.config_file_name = config_file
         cfp = configparser.ConfigParser()
-        cfp.read(config_file, encoding='utf-8')
+        try:
+            cfp.read(self.config_file_name, encoding="utf-8")
+        except Exception as e:
+            logger.error("fail to read {}, due to {}", self.config_file_name, e)
         self._cfp = cfp
         self.md5_hash = calculate_file_hash(config_file)
 
     def update_config(self):
         md5_hash = calculate_file_hash(self.config_file_name)
         if md5_hash == self.md5_hash:
             return False
 
-        self.md5_hash = md5_hash
         cfp = configparser.ConfigParser()
-        cfp.read(self.config_file_name, encoding='utf-8')
-        self._cfp = cfp
+        try:
+            cfp.read(self.config_file_name, encoding="utf-8")
+            self._cfp = cfp
+            self.md5_hash = md5_hash
+        except Exception as e:
+            logger.error("fail to read {}, due to {}", self.config_file_name, e)
         return True
 
     def get_sections(self):
         return self._cfp.sections()
 
     def get_value(self, key: str, default_value: str = None) -> str:
         """
         key的格式: section.option
 
         [section]
         option=value
         """
-        if '.' in key:
-            ll = key.split('.')
+        if "." in key:
+            ll = key.split(".")
             section = ll[0]
             option = ll[1]
             if self._cfp.has_option(section, option):
-                return self._cfp.get(section, option)
+                return self._cfp.get(section, option).strip('"')
             return default_value
         return default_value
 
     def get_list(self, key: str, default_value: list = []) -> list:
         """
         key的格式: section.option
 
         [section]
         option=v1,v2,v3,v4
         @return [v1, v2, v3, v4]
         """
         str_val = self.get_value(key, "")
         if not str_val:
             return default_value
-        str_list = [i.strip() for i in str_val.split(",") if i.strip()]
+        str_list = [i.strip().strip('"') for i in str_val.split(",") if i.strip()]
         return str_list
 
     def get_floatlist(self, key: str, default_value: list = []) -> list:
         """
         key的格式: section.option
 
         [section]
@@ -100,47 +108,47 @@
     def get_floatvalue(self, key: str, default_value: float = None) -> float:
         """
         key的格式: section.option
 
         [section]
         option=value
         """
-        if '.' in key:
-            ll = key.split('.')
+        if "." in key:
+            ll = key.split(".")
             section = ll[0]
             option = ll[1]
             if self._cfp.has_option(section, option):
                 return self._cfp.getfloat(section, option)
             return default_value
         return default_value
 
     def get_intvalue(self, key: str, default_value: int = None) -> int:
         """
         key的格式: section.option
 
         [section]
         option=value
         """
-        if '.' in key:
-            ll = key.split('.')
+        if "." in key:
+            ll = key.split(".")
             section = ll[0]
             option = ll[1]
             if self._cfp.has_option(section, option):
                 return self._cfp.getint(section, option)
             return default_value
         return default_value
 
     def get_booleanvalue(self, key: str, default_value: bool = None) -> bool:
         """
         key的格式: section.option
 
         [section]
         option=value
         """
-        if '.' in key:
-            ll = key.split('.')
+        if "." in key:
+            ll = key.split(".")
             section = ll[0]
             option = ll[1]
             if self._cfp.has_option(section, option):
                 return self._cfp.getboolean(section, option)
             return default_value
         return default_value
```

## mest/main.py

```diff
@@ -1,70 +1,125 @@
 import os
+from pprint import pprint
 import sys
 import time
 import signal
 import datetime
 import subprocess
 
 import psutil
 from loguru import logger
 
 from .config import Config
 from .rep_mana import MeST
 
-# logger.remove(handler_id=None)
+logger.remove(handler_id=None)
+LOG_FILE = os.path.expanduser("~/.cache/memest")
 logger.add(
-    os.path.expanduser("~/.cache/memest"),
+    LOG_FILE,
     rotation="00:00",
-    retention=datetime.timedelta(days=7),
+    retention=datetime.timedelta(days=1),
     backtrace=True,
     diagnose=True,
     enqueue=True,
 )
 USAGE = """ USAGE memest [cmd]
-cmd: start, status, stop
+cmd: start, status, stop, restart
 """
 
+CONFIG_FILE = os.path.expanduser("~/.config/memest/config.ini")
+
+
+def get_log_error():
+    error_lines = []
+    for line in open(LOG_FILE, "r").read().splitlines():
+        if "ERROR" in line:
+            error_lines.append(line)
+    content = "\n".join(error_lines[-10:])
+    return content
+
+
+def kill_process_tree(pid):
+    sig = signal.SIGKILL
+    pid_list = [pid]
+    while True:
+        if len(pid_list) == 0:
+            break
+        tmp_pid = pid_list.pop(0)
+        if not psutil.pid_exists(tmp_pid):
+            continue
+        parent = psutil.Process(tmp_pid)
+        if parent is not None:
+            children = parent.children(recursive=False)
+            if children is not None:
+                for child in children:
+                    pid_list.append(child.pid)
+            cmdline = " ".join(parent.cmdline())
+            print(f"kill {parent.pid} {cmdline}")
+            parent.send_signal(sig)
+
+
+def init_check():
+    if not os.path.exists(CONFIG_FILE):
+        print(f"please set `{CONFIG_FILE}`")
+        exit(1)
+
+
+def show_status():
+    if is_memest_daemon_running():
+        print("memest is running")
+    else:
+        print("memest is dead")
+        return
+    cfg = Config(CONFIG_FILE)
+    all_rep = [i for i in cfg.get_sections() if i != "default"]
+    print("sync:", all_rep)
+    err_lines = get_log_error()
+    if err_lines:
+        print(err_lines)
+        print(f"more details in {LOG_FILE}")
+
 
 def is_memest_daemon_running():
     for process in psutil.process_iter(["pid", "name", "cmdline"]):
-        cmdline = " ".join(process.info['cmdline'])
+        cmdline = " ".join(process.info["cmdline"])
         if "--daemon" in cmdline and "memest" in cmdline:
             return True
     return False
 
 
 def stop_memest_daemon():
     for process in psutil.process_iter(["pid", "name", "cmdline"]):
-        cmdline = " ".join(process.info['cmdline'])
+        cmdline = " ".join(process.info["cmdline"])
         if "--daemon" in cmdline and "memest" in cmdline:
-            os.kill(process.info['pid'], signal.SIGKILL)
+            pid = process.info["pid"]
+            kill_process_tree(int(pid))
 
 
 def run_forever():
-    CONFIG_FILE = os.path.expanduser("~/.config/memest/config.ini")
     cfg = Config(CONFIG_FILE)
-    logger.info("config file: {}", CONFIG_FILE)
     mestor = MeST(cfg)
     mestor.run()
 
 
 def main():
     if len(sys.argv) < 2:
         print(USAGE)
         exit(1)
     cmd = sys.argv[1]
+    os.system("mkdir -p ~/.cache/")
+    init_check()
     if cmd == "start":
         if is_memest_daemon_running():
-            logger.info("memest is running")
-        else:
-            logger.info("start memest")
-            os.system('nohup memest --daemon >> /dev/null 2>&1 &')
-    elif cmd == "status":
-        if is_memest_daemon_running():
             print("memest is running")
         else:
-            print("memest is dead")
-    elif cmd == 'stop':
+            print("start memest")
+            os.system("nohup memest --daemon >> /dev/null 2>&1 &")
+    elif cmd == "status":
+        show_status()
+    elif cmd == "stop":
         stop_memest_daemon()
+    elif cmd == "restart":
+        os.system("memest stop")
+        os.system("memest start")
     elif cmd == "--daemon":
         run_forever()
```

## mest/rep_mana.py

```diff
@@ -4,24 +4,25 @@
 from loguru import logger
 
 import git_tools
 
 
 @logger.catch
 def one_cycle_task(rep_data):
-    logger.info("one_cycle_task for {}", rep_data.alias)
+    logger.info("fetch and merge for {}", rep_data.address)
     git_tools.api.init_rep(rep_data)
     git_tools.api.fetch(rep_data)
     git_tools.api.merge_remote_branches(rep_data)
     git_tools.api.push(rep_data)
 
 
-def sync_one_rep(rep):
-    one_cycle_task(rep.local)
-    for rep_data in rep.remote_rep_list:
+def sync_one_rep(rep_cache_data):
+    git_tools.api.check_remotes(rep_cache_data)
+    one_cycle_task(rep_cache_data.local)
+    for rep_data in rep_cache_data.remote_rep_list:
         one_cycle_task(rep_data)
 
 
 class MeST:
     rep_set = {}
 
     def __init__(self, cfg):
@@ -29,29 +30,36 @@
         self.loop_period = self.cfg.get_intvalue("default.loop_period", 5)
         self.cache_dir = os.path.expanduser(self.cfg.get_value("default.cache"))
         git_tools.api.mkdir(self.cache_dir)
 
     def init_rep_set(self):
         all_rep = [i for i in self.cfg.get_sections() if i != "default"]
         logger.info("all_rep: {}", all_rep)
+        self.rep_set = {}
         for k in all_rep:
             work_dir = os.path.join(self.cache_dir, k)
             address = os.path.expanduser(self.cfg.get_value(k + ".local"))
             local_data = git_tools.RepData(address=address, work_dir=work_dir)
+            local_data.alias = "local"
             logger.info("local_data:\n{}", local_data)
             remote_list = []
             for remote_cfg in self.cfg.get_list(k + ".remote", []):
                 address = remote_cfg.split("|")[0].strip()
                 key_file = ""
                 if "|" in remote_cfg:
                     key_file = os.path.expanduser(remote_cfg.split("|")[1].strip())
-                remote_data = git_tools.RepData(address=address, work_dir=work_dir, key_file=key_file)
+                remote_data = git_tools.RepData(
+                    address=address, work_dir=work_dir, key_file=key_file
+                )
                 remote_list.append(remote_data)
                 logger.info("add:\n{}", remote_data)
-            self.rep_set[k] = git_tools.RepCacheData(local=local_data, remote=remote_list)
+            self.rep_set[k] = git_tools.RepCacheData(
+                local=local_data, remote=remote_list
+            )
+            git_tools.api.check_remotes(self.rep_set[k])
 
     def check(self):
         if self.cfg.update_config():
             self.loop_period = self.cfg.get_intvalue("default.loop_period", 5)
             self.init_rep_set()
 
         for rep in self.rep_set.values():
```

## Comparing `MeMeST-2024.4.9.212528.data/data/LICENSE` & `MeMeST-2024.4.946342.data/data/LICENSE`

 * *Files identical despite different names*

## Comparing `MeMeST-2024.4.9.212528.dist-info/LICENSE` & `MeMeST-2024.4.946342.dist-info/LICENSE`

 * *Files identical despite different names*

