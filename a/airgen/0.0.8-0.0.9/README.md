# Comparing `tmp/airgen-0.0.8-py3-none-any.whl.zip` & `tmp/airgen-0.0.9-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,24 @@
-Zip file size: 477591 bytes, number of entries: 117
+Zip file size: 481537 bytes, number of entries: 119
 -rw-rw-r--  2.0 unx     1070 b- defN 24-Jan-12 01:47 airgen/__init__.py
 -rw-rw-r--  2.0 unx    37685 b- defN 24-Jan-12 00:13 airgen/airgen_types.py
--rw-rw-r--  2.0 unx   104498 b- defN 24-Jan-12 01:47 airgen/client.py
+-rw-rw-r--  2.0 unx   105290 b- defN 24-Apr-26 18:31 airgen/client.py
 -rw-rw-r--  2.0 unx      136 b- defN 24-Jan-12 00:06 airgen/connect.py
--rw-rw-r--  2.0 unx    41204 b- defN 24-Jan-12 01:47 airgen/types.py
+-rw-rw-r--  2.0 unx    41209 b- defN 24-Apr-26 18:52 airgen/types.py
 -rw-rw-r--  2.0 unx     3654 b- defN 23-Sep-19 01:30 airgen/asset/rgb2segID.txt
--rw-rw-r--  2.0 unx       67 b- defN 23-Sep-19 01:30 airgen/utils/__init__.py
+-rw-rw-r--  2.0 unx      113 b- defN 24-Jan-30 22:16 airgen/utils/__init__.py
 -rw-rw-r--  2.0 unx     6230 b- defN 23-Dec-07 00:49 airgen/utils/_rgb2segid.py
--rw-rw-r--  2.0 unx    11133 b- defN 24-Jan-12 01:47 airgen/utils/collect.py
--rw-rw-r--  2.0 unx     3177 b- defN 24-Jan-12 01:47 airgen/utils/general.py
--rw-rw-r--  2.0 unx     4410 b- defN 24-Jan-12 01:47 airgen/utils/geodetic.py
--rw-rw-r--  2.0 unx    11912 b- defN 24-Jan-12 01:47 airgen/utils/mechanics.py
--rw-rw-r--  2.0 unx     8209 b- defN 24-Jan-12 01:47 airgen/utils/sensor.py
--rw-rw-r--  2.0 unx     4494 b- defN 24-Jan-12 01:47 airgen/utils/visualize.py
+-rw-rw-r--  2.0 unx    11133 b- defN 24-Jan-30 22:16 airgen/utils/collect.py
+-rw-rw-r--  2.0 unx     3087 b- defN 24-Jan-30 22:16 airgen/utils/general.py
+-rw-rw-r--  2.0 unx     4717 b- defN 24-Jan-30 22:16 airgen/utils/geodetic.py
+-rw-rw-r--  2.0 unx     7456 b- defN 24-Jan-30 22:16 airgen/utils/mechanics.py
+-rw-rw-r--  2.0 unx     5766 b- defN 24-Jan-30 22:16 airgen/utils/sensor.py
+-rw-rw-r--  2.0 unx    23588 b- defN 24-Jan-30 22:16 airgen/utils/trajectory.py
+-rw-rw-r--  2.0 unx     4628 b- defN 24-Jan-30 22:16 airgen/utils/vision.py
+-rw-rw-r--  2.0 unx     4533 b- defN 24-Apr-26 18:31 airgen/utils/visualize.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Sep-19 01:30 airgen_third_party/__init__.py
 -rw-rw-r--  2.0 unx      214 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/__init__.py
 -rw-rw-r--  2.0 unx       20 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/_version.py
 -rw-rw-r--  2.0 unx     1012 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/address.py
 -rw-rw-r--  2.0 unx     1053 b- defN 24-Jan-12 01:47 airgen_third_party/msgpackrpc/client.py
 -rw-rw-r--  2.0 unx      321 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/compat.py
 -rw-rw-r--  2.0 unx      699 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/error.py
@@ -34,15 +36,15 @@
 -rw-rw-r--  2.0 unx    14415 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/escape.py
 -rw-rw-r--  2.0 unx    46547 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/gen.py
 -rw-rw-r--  2.0 unx    31992 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/http1connection.py
 -rw-rw-r--  2.0 unx    27704 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/httpclient.py
 -rw-rw-r--  2.0 unx    13014 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/httpserver.py
 -rw-rw-r--  2.0 unx    33064 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/httputil.py
 -rw-rw-r--  2.0 unx    40581 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/ioloop.py
--rw-rw-r--  2.0 unx    66058 b- defN 24-Jan-12 01:47 airgen_third_party/msgpackrpc/tornado/iostream.py
+-rw-rw-r--  2.0 unx    66058 b- defN 24-Jan-30 22:16 airgen_third_party/msgpackrpc/tornado/iostream.py
 -rw-rw-r--  2.0 unx    20356 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/locale.py
 -rw-rw-r--  2.0 unx    15416 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/locks.py
 -rw-rw-r--  2.0 unx    12510 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/log.py
 -rw-rw-r--  2.0 unx    20910 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/netutil.py
 -rw-rw-r--  2.0 unx    21460 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/options.py
 -rw-rw-r--  2.0 unx    12861 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/process.py
 -rw-rw-r--  2.0 unx    10429 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/queues.py
@@ -106,14 +108,14 @@
 -rw-rw-r--  2.0 unx     4774 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/test/util.py
 -rw-rw-r--  2.0 unx     7505 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/test/util_test.py
 -rw-rw-r--  2.0 unx   114292 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/test/web_test.py
 -rw-rw-r--  2.0 unx    22926 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/test/websocket_test.py
 -rw-rw-r--  2.0 unx      859 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/test/windows_test.py
 -rw-rw-r--  2.0 unx     3790 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/tornado/test/wsgi_test.py
 -rw-rw-r--  2.0 unx        0 b- defN 23-Sep-19 01:30 airgen_third_party/msgpackrpc/transport/__init__.py
--rw-rw-r--  2.0 unx     5459 b- defN 24-Jan-12 01:47 airgen_third_party/msgpackrpc/transport/tcp.py
--rw-rw-r--  2.0 unx        0 b- defN 24-Jan-12 01:49 airgen-0.0.8.dist-info/LICENSE
--rw-rw-r--  2.0 unx      797 b- defN 24-Jan-12 01:49 airgen-0.0.8.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 24-Jan-12 01:49 airgen-0.0.8.dist-info/WHEEL
--rw-rw-r--  2.0 unx       26 b- defN 24-Jan-12 01:49 airgen-0.0.8.dist-info/top_level.txt
--rw-rw-r--  2.0 unx    12224 b- defN 24-Jan-12 01:49 airgen-0.0.8.dist-info/RECORD
-117 files, 1794528 bytes uncompressed, 457499 bytes compressed:  74.5%
+-rw-rw-r--  2.0 unx     5459 b- defN 24-Apr-26 18:33 airgen_third_party/msgpackrpc/transport/tcp.py
+-rw-rw-r--  2.0 unx        0 b- defN 24-Apr-29 21:04 airgen-0.0.9.dist-info/LICENSE
+-rw-rw-r--  2.0 unx      817 b- defN 24-Apr-29 21:04 airgen-0.0.9.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-Apr-29 21:04 airgen-0.0.9.dist-info/WHEEL
+-rw-rw-r--  2.0 unx       26 b- defN 24-Apr-29 21:04 airgen-0.0.9.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx    12387 b- defN 24-Apr-29 21:04 airgen-0.0.9.dist-info/RECORD
+119 files, 1817127 bytes uncompressed, 461197 bytes compressed:  74.6%
```

## zipnote {}

```diff
@@ -33,14 +33,20 @@
 
 Filename: airgen/utils/mechanics.py
 Comment: 
 
 Filename: airgen/utils/sensor.py
 Comment: 
 
+Filename: airgen/utils/trajectory.py
+Comment: 
+
+Filename: airgen/utils/vision.py
+Comment: 
+
 Filename: airgen/utils/visualize.py
 Comment: 
 
 Filename: airgen_third_party/__init__.py
 Comment: 
 
 Filename: airgen_third_party/msgpackrpc/__init__.py
@@ -330,23 +336,23 @@
 
 Filename: airgen_third_party/msgpackrpc/transport/__init__.py
 Comment: 
 
 Filename: airgen_third_party/msgpackrpc/transport/tcp.py
 Comment: 
 
-Filename: airgen-0.0.8.dist-info/LICENSE
+Filename: airgen-0.0.9.dist-info/LICENSE
 Comment: 
 
-Filename: airgen-0.0.8.dist-info/METADATA
+Filename: airgen-0.0.9.dist-info/METADATA
 Comment: 
 
-Filename: airgen-0.0.8.dist-info/WHEEL
+Filename: airgen-0.0.9.dist-info/WHEEL
 Comment: 
 
-Filename: airgen-0.0.8.dist-info/top_level.txt
+Filename: airgen-0.0.9.dist-info/top_level.txt
 Comment: 
 
-Filename: airgen-0.0.8.dist-info/RECORD
+Filename: airgen-0.0.9.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## airgen/client.py

```diff
@@ -6,14 +6,15 @@
 from enum import Enum
 import numpy as np
 import logging
 
 # from .utils import *
 from airgen import airgen_logger
 from .types import *
+from .utils.sensor import *
 import msgpackrpc
 
 
 class VehicleClient:
     def __init__(
         self,
         ip="",
@@ -350,14 +351,37 @@
             "simGetImage", camera_name, image_type, vehicle_name, external
         )
         if result == "" or result == "\0":
             return None
         return result
 
     # camera control
+
+    def getImages(
+        self, camera_name, image_types: List[ImageType], vehicle_name=""
+    ) -> List[ImageResponse]:
+        """
+        Get multiple images
+
+        Args:
+            camera_name (str) : Name of camera to obtain images from
+            image_types (list[ImageType]): Images required
+            vehicle_name (str, optional): Name of vehicle associated with the camera
+
+        Returns:
+            list[ImageResponse]:
+        """
+        requests = []
+        for image_type in image_types:
+            requests.append(imagetype2request(camera_name, image_type))
+        responses_raw = self.simGetImages(requests, vehicle_name, external=False)
+        images = responses2images(responses_raw)
+
+        return images
+
     # simGetImage returns compressed png in array of bytes
     # image_type uses one of the ImageType members
     def simGetImages(
         self, requests: ImageRequest, vehicle_name="", external=False
     ) -> List[ImageResponse]:
         """
         Get multiple images
@@ -2650,16 +2674,16 @@
         )
 
     getRotorStates.__annotations__ = {"return": RotorStates}
 
 
 # ----------------------------------- Car APIs ---------------------------------------------
 class CarClient(VehicleClient, object):
-    def __init__(self, ip="", port=41451, timeout_value=3600):
-        super(CarClient, self).__init__(ip, port, timeout_value)
+    def __init__(self, ip="", port=41451, geo=False, timeout_value=3600):
+        super(CarClient, self).__init__(ip, port, timeout_value, geo)
 
     def setCarControls(self, controls, vehicle_name=""):
         """
         Control the car using throttle, steering, brake, etc.
 
         Args:
             controls (CarControls): Struct containing control values
@@ -2746,11 +2770,11 @@
         )
     elif robot_client_class == CarClient and geo:
         raise ValueError("CarClient does not support geo frame")
     else:
         client = robot_client_class(ip=host, port=port, geo=geo)
     client.confirmConnection()
     ## temp fix that the first segmentation image is not properly rendered
-    client.simGetImages(
-        [ImageRequest("front_center", ImageType.Segmentation, False, False)]
-    )
+    # client.simGetImages(
+    #     [ImageRequest("front_center", ImageType.Segmentation, False, False)]
+    # )
     return client
```

## airgen/types.py

```diff
@@ -402,15 +402,15 @@
         x = axis[0] * sin_half_angle
         y = axis[1] * sin_half_angle
         z = axis[2] * sin_half_angle
 
         return Quaternionr(w, x, y, z)
     
     @classmethod
-    def from_euler_angles(pitch: float, roll: float, yaw: float):
+    def from_euler_angles(cls, pitch: float, roll: float, yaw: float):
         """transform from euler angles to quaternion
 
         Args:
             pitch (float): pitch in radians. Positive pitch means tilt upward
             roll (float): roll in radians
             yaw (float): roll in radians
```

## airgen/utils/__init__.py

```diff
@@ -1,3 +1,5 @@
 from . import sensor
 from . import mechanics
 from . import general
+from . import trajectory
+from . import vision
```

## airgen/utils/general.py

```diff
@@ -1,16 +1,15 @@
 from __future__ import annotations
 
 from typing import List, Dict, Any
 import sys
 import os
 import inspect
-import numpy as np  # pip install numpy
+import numpy as np
 
-from airgen.client import MultirotorClient, VehicleClient, CarClient
 from airgen.types import Vector3r, Quaternionr, ImageRequest, ImageType
 
 
 def vector3d2list(vector3d: Vector3r) -> List[float]:
     """turn an AirGen Vector3r into a list of three floats
 
     Args:
```

## airgen/utils/geodetic.py

```diff
@@ -94,14 +94,26 @@
     x = -slat * clon * ned_pos.x_val + -slon * ned_pos.y_val + -clat * clon * ned_pos.z_val
     y = -slat * slon * ned_pos.x_val + clon * ned_pos.y_val + -clat * slon * ned_pos.z_val
     z = clat * ned_pos.x_val + -slat * ned_pos.z_val
 
     return Vector3r(x + ref_ecef.x_val, y + ref_ecef.y_val, z + ref_ecef.z_val)
 
 
+def ned2lla(ned_pos: Vector3r, ref: GeoPoint) -> GeoPoint:
+    # pylint: disable=C0103
+    """
+    Convert NED to LLA. Units on reference latitude and longitude are radians.
+    Units on reference altitude and NED position are meters.
+    """
+
+    ecef = ned2ecef(ned_pos, ref)
+
+    return ecef2lla(ecef)
+
+
 def ecef2lla(ecef: Vector3r) -> GeoPoint:
     # pylint: disable=C0103
     """Convert ECEF (m, m, m) to LLA (deg, deg, m)"""
     lla = GeoPoint(0, 0, 0)
 
     a = EARTH_SEMI_MAJOR_AXIS
     e2 = ECC_SQUARED
```

## airgen/utils/mechanics.py

```diff
@@ -99,112 +99,14 @@
         np.ndarray: quaternion in xyzw format
     """
     return np.array(
         [quat_wxyz[1], quat_wxyz[2], quat_wxyz[3], quat_wxyz[0]], dtype=NP_FLOATING_TYPE
     )
 
 
-def build_camera_intrinsic(camera_params: dict) -> ivy_vision.Intrinsics:
-    """given airgen camera parameters, build camera intrinsic matrix
-
-    Args:
-        camera_params (dict): aigen camera parameters
-
-    Returns:
-        ivy_vision.Intrinsics:
-    """
-    pp_offset = np.array(
-        [item / 2 - 0.5 for item in [camera_params["width"], camera_params["height"]]],
-        dtype=NP_FLOATING_TYPE,
-    )
-    persp_angle = np.array(
-        [camera_params["fov"] * np.pi / 180] * 2, dtype=NP_FLOATING_TYPE
-    )
-    intrinsic = ivy_vision.persp_angles_and_pp_offsets_to_intrinsics_object(
-        persp_angle, pp_offset, [camera_params["width"], camera_params["height"]]
-    )
-    return intrinsic
-
-
-def build_camera_inv_extrinsic(camera_params: dict) -> ivy.Array:
-    """given airgen camera parameters, build camera inverse extrinsic matrix
-
-    Args:
-        camera_params (dict): airgen camera parameters
-
-    Returns:
-        ivy.Array: inverse of camera extrinsic matrix
-    """
-    cam_position = np.array(camera_params["camera_position"], dtype=NP_FLOATING_TYPE)
-    cam_quaternion = quat_wxyz_to_xyzw(camera_params["camera_orientation_quat_wxyz"])
-    cam_quat_poses = ivy.concat((cam_position, cam_quaternion), axis=-1)
-
-    cam_inv_ext_mat = ivy_mech.quaternion_pose_to_mat_pose(cam_quat_poses)
-    return cam_inv_ext_mat
-
-
-def build_camera(camera_params: dict) -> Tuple[ivy.Array, ivy.Array]:
-    """given airgen camera parameters, build camera inverse extrinsic matrix and camera intrinsic matrix
-
-    Args:
-        camera_params (dict): airgen camera parameters
-
-    Returns:
-        Tuple[ivy.Array, ivy.Array]: inverse of camera extrinsic matrix and inverse of camera calibration matrix
-    """
-    intrinsic = build_camera_intrinsic(camera_params)
-    cam_inv_calib_mat = intrinsic.inv_calib_mats
-    cam_inv_ext_mat = build_camera_inv_extrinsic(camera_params)
-    return cam_inv_ext_mat, cam_inv_calib_mat
-
-
-def camera_unproject_depth(
-    depth: np.ndarray, cam_inv_ext_mat: ivy.Array, cam_inv_calib_mat: ivy.Array
-) -> np.ndarray:
-    """generate point cloud from depth image (depth perspective)
-
-    Args:
-        depth (np.ndarray): of shape (H, W, 1)
-        cam_inv_ext_mat (ivy.Array): inverse of camera extrinsic matrix
-        cam_inv_calib_mat (ivy.Array): inverse of camera intrinsic matrix
-
-    Returns:
-        np.ndarray: point cloud of shape (N, 3)
-    """
-    uniform_pixel_coords = ivy_vision.create_uniform_pixel_coords_image(
-        image_dims=(depth.shape[0], depth.shape[1])
-    )
-
-    cam_coords = ivy_vision.ds_pixel_to_cam_coords(
-        uniform_pixel_coords,
-        cam_inv_calib_mat,
-        [],
-        image_shape=(depth.shape[0], depth.shape[1]),
-    )
-    # normalize the (non-homogeneous) part of camera coordinates to have unit norm and then scale by depth
-    cam_coords[..., :-1] = (
-        cam_coords[..., :-1]
-        / np.linalg.norm(cam_coords[..., :-1], axis=-1, keepdims=True)
-    ) * depth
-    # camera coordinate to ned
-    camera2ned = np.array(
-        [[0, -1, 0, 0], [0, 0, -1, 0], [1, 0, 0, 0], [0, 0, 0, 1]],
-        dtype=cam_coords.dtype,
-    )
-    # which is the transpose of
-    # camera2ned = np.transpose(
-    #     np.array(
-    #         [[0, 0, 1, 0], [-1, 0, 0, 0], [0, -1, 0, 0], [0, 0, 0, 1]],
-    #         dtype=cam_coords.dtype,
-    #     )
-    # )
-    ned_coords = np.dot(cam_coords, camera2ned)
-    return ivy_vision.cam_to_world_coords(ned_coords, cam_inv_ext_mat)[..., 0:3]
-
-
 def imagecoord2orientation(pixelcoord, camera_param) -> Tuple[float, float, float]:
     """Given camera parameters (position, pose, and fov) and  pixel coordinate, return the 3D direction of the pixel
     with respect to the camera represented in yaw and pitch (absolute degrees)
 
     Args:
         pixelcoord (Tuple[float, float]): coordinate of the pixel in the image in xy format
         camera_param (Dict[str, Any]): camera parameters
@@ -309,45 +211,14 @@
     yaw = np.rad2deg(np.arctan2(vec[:, 1], vec[:, 0]))
     pitch = np.rad2deg(
         np.arctan2(-vec[:, 2], np.sqrt(np.square(vec[:, 0]) + np.square(vec[:, 1])))
     )
     return np.stack([pitch, np.zeros_like(pitch), yaw], axis=1)
 
 
-def depth2pointcloud(
-    depth: np.ndarray,
-    camera_param: dict,
-    mask: Optional[np.ndarray] = None,
-) -> np.ndarray:
-    """generating point cloud from depth image
-
-    Args:
-        depth (np.ndarray): depth image of shape (H, W, 1)
-        camera_param (dict): camera parameters that contains fov, height, width and camera pose
-        mask (Optional[np.ndarray], optional): boolean (0/1) mask where 1 indicates object of interest, (H, W, 1). Defaults to None.
-
-    Returns:
-        np.ndarray: point cloud in airgen world coordinate of shape (N, 3)
-    """
-
-    camera_inv_ext_mat, camera_inv_calib_mat = build_camera(camera_param)
-    point_cloud = camera_unproject_depth(
-        depth=depth,
-        cam_inv_ext_mat=camera_inv_ext_mat,
-        cam_inv_calib_mat=camera_inv_calib_mat,
-    )
-
-    if mask is not None:
-        point_cloud = point_cloud[np.where(mask.squeeze(-1) > 0.5)]
-
-    point_cloud = point_cloud.reshape((-1, 3))
-
-    return point_cloud.to_numpy()
-
-
 def rotate_xy(vec: np.ndarray, theta: float) -> np.ndarray:
     """rotate xy-component of 3d vector by theta (in degrees) counter-clockwise (in xy plane)
 
     Assume looking from positive z-axis, the orientation is
 
     ::
```

## airgen/utils/sensor.py

```diff
@@ -4,24 +4,22 @@
 import re
 import math
 import numpy as np
 import sys
 import time
 from functools import lru_cache
 
-from airgen import airgen_logger
 from airgen.types import ImageType, ImageResponse, ImageRequest
 from .general import list_to_2d_float_array
 from .mechanics import to_eularian_angles
-from ._rgb2segid import rgb2segid
-from ..client import VehicleClient
 
 
 def imagetype2request(
-    camera_name: Literal["front_center", "bottom_center"], image_type: ImageType
+    camera_name: Literal["front_center", "front_left", "front_right", "back_center", "bottom_center"], 
+    image_type: ImageType
 ) -> ImageRequest:
     """helper function that creates uncompressed AirGen ImageRequest for image type
 
     Args:
         camera_name (Literal["front_center", "bottom_center"]):
         image_type (ImageType):
 
@@ -104,16 +102,15 @@
             depth_img_in_meters = np.reshape(
                 np.asarray(response.image_data_float, dtype=np.float32),
                 (response.width, response.height, 1),
             )
             data = depth_img_in_meters
         elif image_type == ImageType.Segmentation:
             img1d = np.frombuffer(response.image_data_uint8, dtype=np.uint8)
-            segmentation_rgb = img1d.reshape(response.height, response.width, 3)
-            data = RGB2SegmentationID(segmentation_rgb)
+            data = img1d.reshape(response.height, response.width, 3)
         elif image_type == ImageType.OpticalFlow:
             optical_flow = np.reshape(
                 response.image_data_float, (response.width, response.height, 2)
             )
             data = optical_flow
         else:
             raise ValueError(f"image type {image_type} not recognized")
@@ -133,69 +130,8 @@
         camera_params["camera_orientation_quat_wxyz"] = [
             response.camera_orientation.w_val,
             response.camera_orientation.x_val,
             response.camera_orientation.y_val,
             response.camera_orientation.z_val,
         ]
         res.append((data, camera_params))
-    return res
-
-
-def RGB2SegmentationID(RGB: np.ndarray) -> np.ndarray:
-    """Map a airgen segmentation image (in rgb format) to 1-channel image of segmentation IDs"""
-    seg = np.zeros((RGB.shape[0], RGB.shape[1], 1), dtype=np.uint8)
-    # todo: vectorize this!
-    for i in range(RGB.shape[0]):
-        for j in range(RGB.shape[1]):
-            seg_id = rgb2segid.get(tuple(RGB[i, j]), 256)
-
-            if seg_id == 256:
-                # airgen_logger.warning(
-                #     "RGB value not found in mapping: %s, and it set to 255",
-                #     str(RGB[i, j]),
-                # )
-                seg[i, j, 0] = 255
-            else:
-                seg[i, j, 0] = seg_id
-    return seg
-
-
-def compute_mapping_of_rgbgsegID() -> Tuple[dict, dict]:
-    """re-compute mapping between rbg tuples to segmentation IDs by querying airgen
-
-    Note:
-        make sure airgen is running and the environment is loaded, and majority of the contents captured by front center camera is meaningful scene (not sky)
-
-    Returns:
-        Tuple[dict, dict]: segid2rgb, rgb2segid
-    """
-    client = VehicleClient(timeout_value=7200)
-    client.confirmConnection()
-
-    requests = ImageRequest("0", ImageType.Segmentation, False, False)
-
-    # for
-    id2rgb = {}
-    rgb2id = {}
-    for cls_id in range(256):
-        # map every asset to cls_id and extract the single RGB value produced
-        client.simSetSegmentationObjectID("[\w]*", cls_id, is_name_regex=True)
-        time.sleep(2.0)
-        response = client.simGetImages([requests])[0]
-        img1d = np.frombuffer(response.image_data_uint8, dtype=np.uint8)
-        img_rgb = img1d.reshape(response.height, response.width, 3)
-        # find the most frequent rgb color
-        img_2d = img_rgb.reshape(-1, 3)
-
-        # Find the unique rows and their counts
-        unique_rgb_values, unique_counts = np.unique(img_2d, axis=0, return_counts=True)
-
-        # Find the index of the RGB value with the maximum count
-        most_frequent_index = np.argmax(unique_counts)
-
-        # color = tuple(np.unique(img_rgb.reshape(-1, img_rgb.shape[-1]), axis=0)[1])
-        # in the env currently being tested, the sky is always 0
-        color = tuple(unique_rgb_values[most_frequent_index])
-        id2rgb[cls_id] = color
-        rgb2id[color] = cls_id
-
-    return id2rgb, rgb2id
+    return res
```

## airgen/utils/visualize.py

```diff
@@ -1,14 +1,13 @@
 from typing import Any, Callable, Dict
 import math
 import numpy as np
 import rerun as rr
 
-from airgen.types import ImageType
-from airgen.utils.mechanics import to_quaternion
+from airgen.types import ImageType, Quaternionr
 
 
 def rr_log_airgen_image(
     entity_path: str, image_type: ImageType, image: np.ndarray, image_name: str = ""
 ):
     """log images from airgen to rerun
 
@@ -22,31 +21,29 @@
         ValueError: ValueError if image_type is not supported
     """
     if image_name:
         entity_path = f"{entity_path}/{image_name}"
     else:
         entity_path = f"{entity_path}/{ImageType.to_str(image_type)}"
     params = (entity_path, image)
-    if image_type in [ImageType.Scene, ImageType.OpticalFlowVis, ImageType.DepthVis]:
-        rr.log_image(*params)
+    if image_type in [ImageType.Scene, ImageType.OpticalFlowVis, ImageType.DepthVis, ImageType.Segmentation, ImageType.Infrared]:
+        rr.log(entity_path, rr.Image(image))
     elif image_type in [
         ImageType.DepthPerspective,
         ImageType.DepthPlanar,
         ImageType.DisparityNormalized,
     ]:
-        rr.log_depth_image(*params)
-    elif image_type in [ImageType.Segmentation, ImageType.Infrared]:
-        rr.log_segmentation_image(*params)
+        rr.log(entity_path, rr.DepthImage(image))
     elif image_type == ImageType.OpticalFlow:
-        rr.log_depth_image(f"{entity_path}_x", image[0])
-        rr.log_depth_image(f"{entity_path}_y", image[1])
+        rr.log(f"{entity_path}_x", rr.DepthImage(image[0]))
+        rr.log(f"{entity_path}_y", rr.DepthImage(image[1]))
     elif image_type == ImageType.SurfaceNormals:
         if image.dtype != np.uint8:
             image = np.round((0.5 * image + 0.5) * 255).astype(np.uint8)
-        rr.log_image(*params)
+        rr.log(entity_path, rr.Image(image))
     else:
         raise ValueError(f"image type {image_type} not supported")
 
 
 def rr_camera_capture_logger(rr_space_view_name: str) -> Callable:
     """Given a view space name (entity_path in rerun), return a function that can be used to log camera data (pose and capture in AirGen's 3D world coordinate) to that view space
 
@@ -55,68 +52,69 @@
 
     Returns:
         Callable: a function that can be used to log camera data to that view space
         def log_camera_data(image: np.ndarray, camera_params: Dict[str, Any], camera_name:str):
             pass
 
     Usage:
-    >>> trajectory_logger = rr_camera_capture_logger("airgen_world")
-    >>> trajectory_logger(image, camera_params, camera_name)
+        >>> trajectory_logger = rr_camera_capture_logger("airgen_world")
+        >>> trajectory_logger(image, camera_params, camera_name)
     """
 
     def camera_quat(camera_params: Dict[str, Any]) -> list[float]:
         # compute camera's quaternion
         euler_angle_rr = [
             angle for angle in camera_params["camera_orientation_euler_pry"]
         ]
         # airgen use NED coordinate, hence pitch positive is downward
         euler_angle_rr[0] = -euler_angle_rr[0]
         euler_angle_rr = tuple(math.radians(x) for x in euler_angle_rr)
-        return to_quaternion(*euler_angle_rr).wxyz
+        return Quaternionr.from_euler_angles(*euler_angle_rr) 
 
     def camera_focal_length(width, height, fov):
         # compute camera's focal lengh given width, height and fov
         assert width == height, "width and height must be equal"
         res = (
             width / (2 * math.tan(math.radians(fov) / 2)),
             height / (2 * math.tan(math.radians(fov) / 2)),
         )
         return res
 
     # airgen use NED coordinate (Z axis points downwards), hence pitch positive is downward
-    rr.log_view_coordinates(rr_space_view_name, xyz="FRD")
+    rr.log(rr_space_view_name, rr.ViewCoordinates.RIGHT_HAND_Z_DOWN, timeless=True)
 
     def log_camera_data(
         image: np.ndarray,
         camera_params: Dict[str, Any],
         camera_name: str = "camera",
     ):
         """log camera data to rerun
 
         Args:
             images (List[Tuple[ImageType, np.ndarray]]): list of tuple (image_name, image)
             camera_params (Dict[str, Any]): camera parameters
             camera_name (str, optional): name of the camera, defaults to "camera".
         """
-        rr.log_transform3d(
+        rr.log(
             f"{rr_space_view_name}/{camera_name}",
-            rr.TranslationRotationScale3D(
-                translation=camera_params["camera_position"],
-                rotation=rr.Quaternion(xyzw=camera_quat(camera_params)),
-            ),
+            rr.Transform3D(
+                            translation=camera_params["camera_position"],
+                            rotation=rr.Quaternion(xyzw=camera_quat(camera_params)) 
+                           )
         )
 
-        rr.log_pinhole(
+        rr.log(
             f"{rr_space_view_name}/{camera_name}",
-            width=camera_params["width"],
-            height=camera_params["height"],
-            focal_length_px=camera_focal_length(
-                camera_params["width"], camera_params["height"], camera_params["fov"]
-            ),
-            camera_xyz="FLU",
+            rr.Pinhole(
+                width=camera_params["width"],
+                height=camera_params["height"],
+                focal_length=camera_focal_length(
+                    camera_params["width"], camera_params["height"], camera_params["fov"]
+                )
+            )   #camera_xyz="FLU",
         )
 
         rr_log_airgen_image(
             f"{rr_space_view_name}/{camera_name}", camera_params["image_type"], image
         )
 
     return log_camera_data
```

## Comparing `airgen-0.0.8.dist-info/METADATA` & `airgen-0.0.9.dist-info/METADATA`

 * *Files 10% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: airgen
-Version: 0.0.8
+Version: 0.0.9
 Summary: Aerial robotics simulator
 Home-page: https://scaledfoundations.ai
 Author: Scaled Foundations
 Author-email: info@scaledfoundations.ai
 Classifier: Programming Language :: Python :: 3
 Classifier: Operating System :: OS Independent
 Requires-Python: >=3.8, <=3.11.7
@@ -12,10 +12,11 @@
 License-File: LICENSE
 Requires-Dist: numpy
 Requires-Dist: rerun-sdk >=0.11.0
 Requires-Dist: ivy
 Requires-Dist: ivy-vision ==0.0.1.post0
 Requires-Dist: ivy-mech ==0.0.1.post0
 Requires-Dist: msgpack >=1.0.0
+Requires-Dist: osqp
 
 [![Build pip wheel](https://github.com/ScaledFoundations/pyairgen/actions/workflows/build_wheel.yaml/badge.svg?branch=main)](https://github.com/ScaledFoundations/pyairgen/actions/workflows/build_wheel.yaml)
 # Python API for airgen
```

## Comparing `airgen-0.0.8.dist-info/RECORD` & `airgen-0.0.9.dist-info/RECORD`

 * *Files 2% similar despite different names*

```diff
@@ -1,21 +1,23 @@
 airgen/__init__.py,sha256=C7WWEwCXhk1Cqr5GmRbYDagqE2-MVorVPKZIb8VBsR8,1070
 airgen/airgen_types.py,sha256=eANdEE09w15jmGqRKR2r_85ep2HJCmPiXKFLwLg9DSw,37685
-airgen/client.py,sha256=Oph5jq4qHpe8MHk1VOjApK_G8wS_Zd874KgLq-uWrpE,104498
+airgen/client.py,sha256=Pl5Yae0EguWTj7-uE3K3WrcSXQfjkbS0WfnDFDJAqUo,105290
 airgen/connect.py,sha256=nCPCY4DBnJRfxgFGxNd9IHVRj_bzmICmNNSkhFRln3I,136
-airgen/types.py,sha256=IS3C5DJlgpmypFVR6kjImxtKeB4BZnOs88eCJThCxQs,41204
+airgen/types.py,sha256=0X87wl_42C06s370d_XQB57CqYN65XIjwNCy4X7tJMs,41209
 airgen/asset/rgb2segID.txt,sha256=ISJBhUUyEAh8Hf6xsTMzzzMvQAKpqfRMxXiT7n-cLJk,3654
-airgen/utils/__init__.py,sha256=azP03FwXlCsuZ4ltnw0PlK5X-EnAqhLuBDnkAWR-SY8,67
+airgen/utils/__init__.py,sha256=ayXgD4WzjnN0VCXqLXlxw40V66F22-uK_62d6fxlIT0,113
 airgen/utils/_rgb2segid.py,sha256=TdvwFE1rX_p4ZGs5Oab6xXDGjVz1bqrWVZPMpzYQ8R8,6230
 airgen/utils/collect.py,sha256=2LgGkJ5qz-gnZCvuOEqUv0Gr8NkBcU0s-bM19jPmdCU,11133
-airgen/utils/general.py,sha256=hmIWahdpKMfl4aboRsMh09oxA90UcvxqkdboME02IHs,3177
-airgen/utils/geodetic.py,sha256=SiyW0qmRYzZE7mg1xbIwlW6Fnp5dmsQHZOtmbelXGgg,4410
-airgen/utils/mechanics.py,sha256=55kprg3Elp4MtzNzkf9dx86yw6NPtEo1aWtOAlLedAE,11912
-airgen/utils/sensor.py,sha256=p9MtR4kf4eGbJHxIRxzI28m3O8ypTOtgSoN1SnRxDFs,8209
-airgen/utils/visualize.py,sha256=mXbehgzjrahh6GsG1jWyN6iKtnghhZCb59Ja9C3ciig,4494
+airgen/utils/general.py,sha256=N9RRpTIwF-SmwLKt_1vtnAA6eTvAnjLAXP1V4hnN-SM,3087
+airgen/utils/geodetic.py,sha256=_M7BtLfb3oGWEYgxrdR383QQLZ5_jaGrn_GUp2E9YvE,4717
+airgen/utils/mechanics.py,sha256=2_u_zC5kDWc_6ISG6nKASHIXFy34vvQPXQgVC66Xt4k,7456
+airgen/utils/sensor.py,sha256=eM_Vq4MKocV6SW6L8PlDwEbm5H9eolTx-aIqkAZ0Ao8,5766
+airgen/utils/trajectory.py,sha256=QjU6z_7iO8aLlomug0WPpA4-qICHNjuI4RCnATCVmSU,23588
+airgen/utils/vision.py,sha256=LoaUu_8uGHDWPdn0LXpPdrR91hAqA80VpG77T1ZC16o,4628
+airgen/utils/visualize.py,sha256=AOsGaC538JprYAgtwe_A1li0kapkimgw48wuJXM4AKw,4533
 airgen_third_party/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 airgen_third_party/msgpackrpc/__init__.py,sha256=HVLy8waxN22EQHyw1r6d3-uNUkQ2PZoMsTTsn1EbnPc,214
 airgen_third_party/msgpackrpc/_version.py,sha256=3PiH-R_CaUKizoOf3K5t3tKZEdES6wDRDvDhJcBczGA,20
 airgen_third_party/msgpackrpc/address.py,sha256=cDkhQCIgCaKugdS0-KiSrTE4L-dxsBv8ZGLrpmipGP0,1012
 airgen_third_party/msgpackrpc/client.py,sha256=AkF2R8A_LqEuljpq3Wt9Oz_xyhO9chhSAnq7hWEULmQ,1053
 airgen_third_party/msgpackrpc/compat.py,sha256=OmyOLB_xsG68mU8gdGsYl8nFRkE2C7lCsy-Fvv0HCP8,321
 airgen_third_party/msgpackrpc/error.py,sha256=C-of23AryaOotCT6PI4upYVyShPvqeSIiBbFs2Y7Fpo,699
@@ -106,12 +108,12 @@
 airgen_third_party/msgpackrpc/tornado/test/util_test.py,sha256=r04nykaYq8SpGqaQLLaPh1vPwQsU5htej6ErdFaY8tU,7505
 airgen_third_party/msgpackrpc/tornado/test/web_test.py,sha256=uf0WBc15hcQL3a4NjGmeLdhCxSzf2Jt0kuomwnCedt0,114292
 airgen_third_party/msgpackrpc/tornado/test/websocket_test.py,sha256=zmztE3FMEYarPWY7yryBHDUsqhOSQdX6kKO6pTPqFJg,22926
 airgen_third_party/msgpackrpc/tornado/test/windows_test.py,sha256=g3ROKD7frap-vyhuN-TodsCGgHLlHySR5YSBhMiXnQw,859
 airgen_third_party/msgpackrpc/tornado/test/wsgi_test.py,sha256=vZSaOZYLCx6Lvm2gZCLX6I5lPtIl6KiVLRQSztzvYKo,3790
 airgen_third_party/msgpackrpc/transport/__init__.py,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
 airgen_third_party/msgpackrpc/transport/tcp.py,sha256=mVcPbowmaZLLvTj28z3S91pRnQdDcozvto1DrSnauvs,5459
-airgen-0.0.8.dist-info/LICENSE,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
-airgen-0.0.8.dist-info/METADATA,sha256=JYJI9N-4XkcsZlm698n2eMQaQ1VX9yrjJz1eD-cmLN4,797
-airgen-0.0.8.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
-airgen-0.0.8.dist-info/top_level.txt,sha256=J3fHo891yN8kaELS4fHKiRnYgLW9MHGkaNamLWQm5TE,26
-airgen-0.0.8.dist-info/RECORD,,
+airgen-0.0.9.dist-info/LICENSE,sha256=47DEQpj8HBSa-_TImW-5JCeuQeRkm5NMpJWZG3hSuFU,0
+airgen-0.0.9.dist-info/METADATA,sha256=3fCPt4eBheh3wAzrrK3RtvT6wazjCZbkg9asqTUAbQA,817
+airgen-0.0.9.dist-info/WHEEL,sha256=yQN5g4mg4AybRjkgi-9yy4iQEFibGQmlz78Pik5Or-A,92
+airgen-0.0.9.dist-info/top_level.txt,sha256=J3fHo891yN8kaELS4fHKiRnYgLW9MHGkaNamLWQm5TE,26
+airgen-0.0.9.dist-info/RECORD,,
```

